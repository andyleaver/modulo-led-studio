from __future__ import annotations
SHIPPED = True

from typing import List, Tuple
import math

from behaviors.registry import BehaviorDef, register

RGB = Tuple[int,int,int]

def _clamp01(x: float) -> float:
    if x < 0.0: return 0.0
    if x > 1.0: return 1.0
    return x

def _apply_brightness(rgb: RGB, br: float) -> RGB:
    br = _clamp01(float(br))
    r,g,b = rgb
    return (int(r*br)&255, int(g*br)&255, int(b*br)&255)

USES = ["color","brightness","speed","width","softness"]

def _preview_emit(*, num_leds: int, params: dict, t: float) -> List[RGB]:
    n = max(1, int(num_leds))
    col = params.get("color", (255,255,255))
    br = float(params.get("brightness", 1.0))
    speed = float(params.get("speed", 1.0))
    width = _clamp01(float(params.get("width", 0.25)))      # dot size
    softness = _clamp01(float(params.get("softness", 0.4))) # blur
    base = _apply_brightness((int(col[0])&255, int(col[1])&255, int(col[2])&255), br)

    dot_count = 6
    dot_size = max(1, int(round(width * n * 0.25)))
    blur = max(0.5, softness * 3.5)

    out = [(0,0,0) for _ in range(n)]
    for k in range(dot_count):
        u = (t * max(0.1, speed) * (0.35 + 0.12*k) + k*0.17) % 1.0
        pos = 0.5 - 0.5*math.cos(2.0*math.pi*u)  # 0..1
        x = pos * (n-1 if n>1 else 1)
        for i in range(n):
            d = abs(i - x)
            a = math.exp(-(d*d)/(2.0*blur*blur))
            if d <= dot_size + 6:
                out[i] = (min(255, out[i][0] + int(base[0]*a)),
                          min(255, out[i][1] + int(base[1]*a)),
                          min(255, out[i][2] + int(base[2]*a)))
    return out

def _arduino_emit(*, layout: dict, params: dict) -> str:
    n = int(layout["num_leds"])
    pin = int(layout["led_pin"])
    col = params.get("color",(255,255,255))
    br = float(params.get("brightness", 1.0))
    speed = float(params.get("speed", 1.0))
    width = float(params.get("width", 0.25))
    softness = float(params.get("softness", 0.4))

    if br < 0.0: br = 0.0
    if br > 1.0: br = 1.0
    if width < 0.0: width = 0.0
    if width > 1.0: width = 1.0
    if softness < 0.0: softness = 0.0
    if softness > 1.0: softness = 1.0

    r0 = int(int(col[0]) * br) & 255
    g0 = int(int(col[1]) * br) & 255
    b0 = int(int(col[2]) * br) & 255

    dot_count = 6
    dot_size = int(max(1.0, round(width * float(n) * 0.25)))
    blur = float(max(0.5, softness * 3.5))

    # period_ms sets motion speed
    period_ms = int(max(500.0, min(20000.0, 9000.0 / max(0.2, speed))))

    return f"""// Generated by Modulo (Effect: juggle)
#include <FastLED.h>
#include <math.h>

#define NUM_LEDS {n}
#define LED_PIN {pin}
CRGB leds[NUM_LEDS];

static inline float gauss(float d, float sigma) {{
  return expf(-(d*d) / (2.0f*sigma*sigma));
}}

void setup() {{
  FastLED.addLeds<WS2812B, LED_PIN, GRB>(leds, NUM_LEDS);
  FastLED.setBrightness(255);
}}

void loop() {{
  unsigned long now = millis();
  float t = (float)(now % (unsigned long){period_ms}) / (float){period_ms}; // 0..1

  for (int i=0; i<NUM_LEDS; i++) leds[i] = CRGB(0,0,0);

  for (int k=0; k<{dot_count}; k++) {{
    float kk = (float)k;
    float u = fmodf(t * (0.35f + 0.12f*kk) + kk*0.17f, 1.0f);
    float pos = 0.5f - 0.5f * cosf(2.0f * 3.1415926f * u);
    float x = pos * (float)(NUM_LEDS - 1);

    for (int i=0; i<NUM_LEDS; i++) {{
      float d = fabsf((float)i - x);
      if (d > (float)({dot_size} + 6)) continue;
      float a = gauss(d, (float){blur}f);
      uint8_t r = (uint8_t)fminf(255.0f, (float)leds[i].r + (float){r0}f * a);
      uint8_t g = (uint8_t)fminf(255.0f, (float)leds[i].g + (float){g0}f * a);
      uint8_t b = (uint8_t)fminf(255.0f, (float)leds[i].b + (float){b0}f * a);
      leds[i] = CRGB(r,g,b);
    }}
  }}

  FastLED.show();
  delay(1);
}}
"""

def register_juggle():
    return register(BehaviorDef(
        "juggle",
        title="Juggle / Multi-Dot",
        uses=USES,
        preview_emit=_preview_emit,
        arduino_emit=_arduino_emit,
    ))
