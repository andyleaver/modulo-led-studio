from __future__ import annotations
SHIPPED = True

from typing import List, Tuple
import math

from behaviors.registry import BehaviorDef, register

RGB = Tuple[int,int,int]

def _clamp01(x: float) -> float:
    if x < 0.0: return 0.0
    if x > 1.0: return 1.0
    return x

def _apply_brightness(rgb: RGB, br: float) -> RGB:
    br = _clamp01(float(br))
    r,g,b = rgb
    return (int(r*br)&255, int(g*br)&255, int(b*br)&255)

def _hash_u32(x: int) -> int:
    x = (x ^ 0x9E3779B9) & 0xFFFFFFFF
    x = (x * 0x85EBCA6B) & 0xFFFFFFFF
    x = (x ^ (x >> 13)) & 0xFFFFFFFF
    x = (x * 0xC2B2AE35) & 0xFFFFFFFF
    x = (x ^ (x >> 16)) & 0xFFFFFFFF
    return x

def _u01(h: int) -> float:
    return float(h & 0xFFFFFF) / float(0x1000000)

USES = ["color","brightness","speed","width","softness","density"]

def _preview_emit(*, num_leds: int, params: dict, t: float) -> List[RGB]:
    n = max(1, int(num_leds))
    col = params.get("color",(255,140,0))
    br = float(params.get("brightness", 1.0))
    speed = float(params.get("speed", 1.0))
    width = _clamp01(float(params.get("width", 0.22)))       # ring thickness
    softness = _clamp01(float(params.get("softness", 0.55))) # falloff
    density = _clamp01(float(params.get("density", 0.35)))   # burst rate

    if width < 0.02: width = 0.02
    base = (int(col[0])&255, int(col[1])&255, int(col[2])&255)

    # bucketed bursts
    bps = max(0.2, speed) * (0.6 + density * 2.0)  # bursts per second
    b = int(t * bps)
    u = (t * bps) - float(b)  # 0..1 within burst
    # randomize center per burst
    h = _hash_u32(b ^ 0xE911)
    center = _u01(h)  # 0..1 along strip
    # burst radius grows
    r = u  # 0..1
    # gaussian around ring edge
    sigma = 0.02 + width * (0.20 + softness * 0.9)

    out: List[RGB] = []
    for i in range(n):
        x = i / max(1.0, (n-1))
        d = abs(x - center)
        # ring at distance r*0.6 (keep mostly in range)
        edge = r * 0.6
        du = abs(d - edge)
        a = math.exp(-(du*du)/(2.0*sigma*sigma))
        # add "core flash" early
        core = math.exp(-(d*d)/(2.0*(sigma*0.7)*(sigma*0.7))) * (1.0 - u)
        a = max(a, core*0.8)
        # fade out end
        a *= (1.0 - 0.35*u)
        out.append(_apply_brightness(base, br * a))
    return out

def _arduino_emit(*, layout: dict, params: dict) -> str:
    n = int(layout["num_leds"])
    pin = int(layout["led_pin"])
    col = params.get("color",(255,140,0))
    br = float(params.get("brightness", 1.0))
    speed = float(params.get("speed", 1.0))
    width = float(params.get("width", 0.22))
    softness = float(params.get("softness", 0.55))
    density = float(params.get("density", 0.35))

    if br < 0.0: br = 0.0
    if br > 1.0: br = 1.0
    if width < 0.02: width = 0.02
    if width > 1.0: width = 1.0
    if softness < 0.0: softness = 0.0
    if softness > 1.0: softness = 1.0
    if density < 0.0: density = 0.0
    if density > 1.0: density = 1.0

    r0,g0,b0 = int(col[0])&255, int(col[1])&255, int(col[2])&255
    bps = max(0.2, speed) * (0.6 + density * 2.0)
    bucket_ms = int(max(180.0, min(60000.0, 1000.0 / bps)))
    sigma = 0.02 + width * (0.20 + softness * 0.9)

    return f"""// Generated by Modulo (Effect: explosion)
#include <FastLED.h>
#include <math.h>

#define NUM_LEDS {n}
#define LED_PIN {pin}
CRGB leds[NUM_LEDS];

static inline float clamp01(float x) {{
  if (x < 0.0f) return 0.0f;
  if (x > 1.0f) return 1.0f;
  return x;
}}

static inline uint32_t hash_u32(uint32_t x) {{
  x ^= 0x9E3779B9u;
  x *= 0x85EBCA6Bu;
  x ^= (x >> 13);
  x *= 0xC2B2AE35u;
  x ^= (x >> 16);
  return x;
}}

static inline float u01(uint32_t h) {{
  return (float)(h & 0xFFFFFFu) / 16777216.0f;
}}

static inline float gauss(float d, float sigma) {{
  return expf(-(d*d) / (2.0f*sigma*sigma));
}}

void setup() {{
  FastLED.addLeds<WS2812B, LED_PIN, GRB>(leds, NUM_LEDS);
  FastLED.setBrightness(255);
}}

void loop() {{
  unsigned long now = millis();
  unsigned long bucket = now / (unsigned long){bucket_ms};
  float u = (float)(now % (unsigned long){bucket_ms}) / (float){bucket_ms}; // 0..1

  uint32_t h = hash_u32((uint32_t)bucket ^ 0x0000E911u);
  float center = u01(h); // 0..1
  float edge = u * 0.6f;
  float sigma = (float){sigma}f;
  float br = clamp01((float){br}f);

  for (int i=0; i<NUM_LEDS; i++) {{
    float x = (NUM_LEDS <= 1) ? 0.0f : ((float)i / (float)(NUM_LEDS - 1));
    float d = fabsf(x - center);
    float du = fabsf(d - edge);
    float a = gauss(du, sigma);
    float core = gauss(d, sigma*0.7f) * (1.0f - u);
    if (core*0.8f > a) a = core*0.8f;
    a *= (1.0f - 0.35f*u);
    float k = br * a;
    leds[i] = CRGB((uint8_t)((float){r0}f*k), (uint8_t)((float){g0}f*k), (uint8_t)((float){b0}f*k));
  }}

  FastLED.show();
  delay(1);
}}
"""

def register_explosion():
    return register(BehaviorDef(
        "explosion",
        title="Explosion / Impact Burst",
        uses=USES,
        preview_emit=_preview_emit,
        arduino_emit=_arduino_emit,
    ))
