from __future__ import annotations
SHIPPED = True

from typing import List, Tuple
import math

from behaviors.registry import BehaviorDef, register

RGB = Tuple[int,int,int]

def _clamp01(x: float) -> float:
    if x < 0.0: return 0.0
    if x > 1.0: return 1.0
    return x

def _hsv_to_rgb(h: float, s: float, v: float) -> RGB:
    h = (h % 1.0) * 6.0
    i = int(h) % 6
    f = h - float(i)
    p = v * (1.0 - s)
    q = v * (1.0 - f * s)
    t = v * (1.0 - (1.0 - f) * s)
    if i == 0: r,g,b = v,t,p
    elif i == 1: r,g,b = q,v,p
    elif i == 2: r,g,b = p,v,t
    elif i == 3: r,g,b = p,q,v
    elif i == 4: r,g,b = t,p,v
    else: r,g,b = v,p,q
    return (int(r*255)&255, int(g*255)&255, int(b*255)&255)

USES = ["brightness","speed","softness","width","density"]

def _preview_emit(*, num_leds: int, params: dict, t: float, state=None) -> List[RGB]:
    n=max(1,int(num_leds))
    br=_clamp01(float(params.get("brightness",1.0)))
    speed=max(0.1,float(params.get("speed",1.0)))
    softness=_clamp01(float(params.get("softness",0.45)))
    width=_clamp01(float(params.get("width",0.35)))   # pulse width
    density=_clamp01(float(params.get("density",0.55))) # sensitivity
    if width < 0.05: width = 0.05

    audio=params.get("_audio_flat") or {}
    L=[float(audio.get(f"l{i}",0.0) or 0.0) for i in range(7)]
    R=[float(audio.get(f"r{i}",0.0) or 0.0) for i in range(7)]
    lE=sum(L)/7.0
    rE=sum(R)/7.0

    if state is None or not isinstance(state, dict):
        state={"l":0.0,"r":0.0,"pulses":[]}
    a=0.05+0.45*softness
    state["l"]=(1.0-a)*state["l"]+a*lE
    state["r"]=(1.0-a)*state["r"]+a*rE

    # trigger pulses when one side exceeds the other
    diff = state["l"] - state["r"]
    thr = 0.08*(1.2-density) + 0.03
    if diff > thr:
        state["pulses"].append([0.0, -1.0, 0.80])  # from right to left, magenta
    elif diff < -thr:
        state["pulses"].append([1.0, +1.0, 0.55])  # from left to right, cyan

    # advance pulses
    dt=1.0/60.0
    v=(0.25+1.4*speed)
    sig=(0.02 + width*0.08)*(0.7+1.6*softness)
    new=[]
    out=[(0,0,0) for _ in range(n)]
    for x,dir,hue in state["pulses"]:
        x = (x + dir*v*dt) % 1.0
        life = 1.0 - min(1.0, (len(new)*0.0))
        # decay with travel
        # keep pulse alive for ~1.2 seconds
        new.append([x,dir,hue])
        pr,pg,pb=_hsv_to_rgb(hue,1.0,1.0)
        for i in range(n):
            xx=i/max(1.0,(n-1))
            d=abs(xx-x)
            d=min(d,1.0-d)
            a0=math.exp(-(d*d)/(2.0*sig*sig))
            a2=a0*br
            if a2<0.001: 
                continue
            out[i]=(min(255,out[i][0]+int(pr*a2)), min(255,out[i][1]+int(pg*a2)), min(255,out[i][2]+int(pb*a2)))
    # limit pulse count
    state["pulses"]=new[-18:]
    # add subtle base
    base=(0.06+0.14*(0.5*(state["l"]+state["r"])))
    for i in range(n):
        if base>0.001:
            out[i]=(min(255,out[i][0]+int(40*base*br)), min(255,out[i][1]+int(10*base*br)), min(255,out[i][2]+int(50*base*br)))
    return out

def _arduino_emit(*, layout: dict, params: dict) -> str:
    n=int(layout["num_leds"]); pin=int(layout["led_pin"])
    br=float(params.get("brightness",1.0))
    speed=max(0.1,float(params.get("speed",1.0)))
    softness=float(params.get("softness",0.45))
    width=float(params.get("width",0.35))
    density=float(params.get("density",0.55))
    if br<0: br=0.0
    if br>1: br=1.0
    if softness<0: softness=0.0
    if softness>1: softness=1.0
    if width<0.05: width=0.05
    if width>1: width=1.0
    if density<0: density=0.0
    if density>1: density=1.0

    alpha=0.05+0.45*softness
    v=(0.25+1.4*speed)
    sig=(0.02 + width*0.08)*(0.7+1.6*softness)
    thr = 0.08*(1.2-density) + 0.03

    MAXP=18

    return f"""// Generated by Modulo (Stereo Call & Response)
#include <FastLED.h>
#include <math.h>

#define NUM_LEDS {n}
#define LED_PIN {pin}
CRGB leds[NUM_LEDS];

// MSGEQ7 pins (default)
const int RESET_PIN = 5;
const int STROBE_PIN = 4;
const int LEFT_PIN = A0;
const int RIGHT_PIN = A1;

float lE=0.0f, rE=0.0f;

struct Pulse {{ float x; float dir; float hue; bool alive; }};
Pulse P[{MAXP}];

static inline float clamp01(float x) {{
  if (x < 0.0f) return 0.0f;
  if (x > 1.0f) return 1.0f;
  return x;
}}

static inline float read01(int pin) {{
  int v = analogRead(pin);
  return clamp01((float)v/1023.0f);
}}

static inline void hsv_to_rgb(float h, float s, float v, uint8_t* r, uint8_t* g, uint8_t* b) {{
  float hh = fmodf(h, 1.0f) * 6.0f;
  int i = (int)floorf(hh) % 6;
  float f = hh - (float)i;
  float p = v * (1.0f - s);
  float q = v * (1.0f - f * s);
  float t = v * (1.0f - (1.0f - f) * s);
  float rr,gg,bb;
  if (i==0) {{ rr=v; gg=t; bb=p; }}
  else if (i==1) {{ rr=q; gg=v; bb=p; }}
  else if (i==2) {{ rr=p; gg=v; bb=t; }}
  else if (i==3) {{ rr=p; gg=q; bb=v; }}
  else if (i==4) {{ rr=t; gg=p; bb=v; }}
  else {{ rr=v; gg=p; bb=q; }}
  *r=(uint8_t)(rr*255.0f); *g=(uint8_t)(gg*255.0f); *b=(uint8_t)(bb*255.0f);
}}

static inline void add_rgb(uint8_t* r, uint8_t* g, uint8_t* b, float ar, float ag, float ab) {{
  float rr = fminf(255.0f, (float)(*r) + ar);
  float gg = fminf(255.0f, (float)(*g) + ag);
  float bb = fminf(255.0f, (float)(*b) + ab);
  *r = (uint8_t)rr; *g = (uint8_t)gg; *b = (uint8_t)bb;
}}

int allocPulse() {{
  for (int i=0;i<{MAXP};i++) if (!P[i].alive) return i;
  return -1;
}}

void setup() {{
  FastLED.addLeds<WS2812B, LED_PIN, GRB>(leds, NUM_LEDS);
  FastLED.setBrightness(255);
  pinMode(RESET_PIN, OUTPUT);
  pinMode(STROBE_PIN, OUTPUT);
  digitalWrite(RESET_PIN, LOW);
  digitalWrite(STROBE_PIN, HIGH);
  for (int i=0;i<{MAXP};i++) P[i].alive=false;
}}

void loop() {{
  // energy
  float L[7], R[7];
  digitalWrite(RESET_PIN, HIGH); delayMicroseconds(5); digitalWrite(RESET_PIN, LOW);
  for (int i=0;i<7;i++) {{
    digitalWrite(STROBE_PIN, LOW); delayMicroseconds(30);
    L[i]=read01(LEFT_PIN);
    R[i]=read01(RIGHT_PIN);
    digitalWrite(STROBE_PIN, HIGH);
  }}
  float le=0.0f,re=0.0f;
  for (int i=0;i<7;i++) {{ le+=L[i]; re+=R[i]; }}
  le/=7.0f; re/=7.0f;
  lE = (1.0f-{alpha}f)*lE + {alpha}f*le;
  rE = (1.0f-{alpha}f)*rE + {alpha}f*re;

  float diff = lE - rE;
  if (diff > {thr}f) {{
    int idx = allocPulse();
    if (idx>=0) {{ P[idx].x=0.0f; P[idx].dir=+1.0f; P[idx].hue=0.80f; P[idx].alive=true; }}
  }} else if (diff < -{thr}f) {{
    int idx = allocPulse();
    if (idx>=0) {{ P[idx].x=1.0f; P[idx].dir=-1.0f; P[idx].hue=0.55f; P[idx].alive=true; }}
  }}

  // clear
  for (int i=0;i<NUM_LEDS;i++) leds[i]=CRGB(0,0,0);

  const float dt=1.0f/60.0f;
  float sig = (float){sig}f;
  float br = clamp01((float){br}f);
  float base = 0.06f + 0.14f*(0.5f*(lE+rE));

  // pulses
  for (int pi=0;pi<{MAXP};pi++) {{
    if (!P[pi].alive) continue;
    P[pi].x = fmodf(P[pi].x + P[pi].dir*(float){v}f*dt + 1.0f, 1.0f);

    uint8_t pr,pg,pb;
    hsv_to_rgb(P[pi].hue, 1.0f, 1.0f, &pr,&pg,&pb);

    for (int i=0;i<NUM_LEDS;i++) {{
      float x = (NUM_LEDS<=1)?0.0f:((float)i/(float)(NUM_LEDS-1));
      float d = fabsf(x - P[pi].x);
      d = fminf(d, 1.0f-d);
      float a = expf(-(d*d)/(2.0f*sig*sig));
      if (a < 0.001f) continue;
      float kf = br*a;
      add_rgb(&leds[i].r,&leds[i].g,&leds[i].b, (float)pr*kf, (float)pg*kf, (float)pb*kf);
    }}
  }}

  // base tint
  for (int i=0;i<NUM_LEDS;i++) {{
    if (base < 0.001f) continue;
    float kf = br*base;
    add_rgb(&leds[i].r,&leds[i].g,&leds[i].b, 40.0f*kf, 10.0f*kf, 50.0f*kf);
  }}

  FastLED.show();
  delay(1);
}}
"""

def register_stereo_call_response():
    return register(BehaviorDef(
        "stereo_call_response",
        title="Stereo Call & Response",
        uses=USES,
        preview_emit=_preview_emit,
        arduino_emit=_arduino_emit,
    ))
