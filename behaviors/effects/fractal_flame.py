from __future__ import annotations
SHIPPED = True

from typing import List, Tuple
import math

from behaviors.registry import BehaviorDef, register

RGB = Tuple[int,int,int]

def _clamp01(x: float) -> float:
    if x < 0.0: return 0.0
    if x > 1.0: return 1.0
    return x

def _lerp(a: float, b: float, t: float) -> float:
    return a + (b-a)*t

def _palette(base: RGB, u: float) -> RGB:
    # flame-ish palette derived from base: black -> base -> white
    u = _clamp01(u)
    r0,g0,b0 = int(base[0])&255, int(base[1])&255, int(base[2])&255
    if u < 0.7:
        t = u / 0.7
        r = int(_lerp(0, r0, t))
        g = int(_lerp(0, g0, t))
        b = int(_lerp(0, b0, t))
    else:
        t = (u - 0.7) / 0.3
        r = int(_lerp(r0, 255, t))
        g = int(_lerp(g0, 255, t))
        b = int(_lerp(b0, 255, t))
    return (r&255, g&255, b&255)

USES = ["color","brightness","speed","width","softness","density"]

def _preview_emit(*, num_leds: int, params: dict, t: float) -> List[RGB]:
    n = max(1, int(num_leds))
    base = params.get("color",(255,80,0))
    base = (int(base[0])&255, int(base[1])&255, int(base[2])&255)
    br = _clamp01(float(params.get("brightness", 1.0)))
    speed = max(0.1, float(params.get("speed", 1.0)))
    width = _clamp01(float(params.get("width", 0.35)))       # spatial frequency
    softness = _clamp01(float(params.get("softness", 0.55))) # contrast shaping
    density = _clamp01(float(params.get("density", 0.55)))   # iteration count

    if width < 0.05: width = 0.05
    freq = (1.0/width) * (0.8 + 1.2*density)
    iters = 3 + int(round(density * 5.0))  # 3..8
    contrast = 0.8 + (1.0-softness) * 1.8

    out: List[RGB] = []
    for i in range(n):
        x = i / max(1.0, (n-1))
        # 1D "fractal-ish" iterative map in [0,1]
        z = x*freq + t*speed*0.12
        z = z - math.floor(z)
        v = 0.0
        for k in range(iters):
            # logistic-like warp + fold
            z = (z * (3.2 + 0.6*math.sin(t*0.2 + k))) % 1.0
            z = abs(z*2.0 - 1.0)
            v += z
        v = v / float(iters)
        v = _clamp01((v - 0.35) * contrast + 0.35)
        r,g,b = _palette(base, v)
        out.append((int(r*br)&255, int(g*br)&255, int(b*br)&255))
    return out

def _arduino_emit(*, layout: dict, params: dict) -> str:
    n = int(layout["num_leds"])
    pin = int(layout["led_pin"])
    base = params.get("color",(255,80,0))
    r0,g0,b0 = int(base[0])&255, int(base[1])&255, int(base[2])&255
    br = float(params.get("brightness", 1.0))
    speed = max(0.1, float(params.get("speed", 1.0)))
    width = float(params.get("width", 0.35))
    softness = float(params.get("softness", 0.55))
    density = float(params.get("density", 0.55))

    if br < 0.0: br = 0.0
    if br > 1.0: br = 1.0
    if width < 0.05: width = 0.05
    if width > 1.0: width = 1.0
    if softness < 0.0: softness = 0.0
    if softness > 1.0: softness = 1.0
    if density < 0.0: density = 0.0
    if density > 1.0: density = 1.0

    freq = (1.0/width) * (0.8 + 1.2*density)
    iters = 3 + int(round(density * 5.0))
    contrast = 0.8 + (1.0-softness) * 1.8
    period_ms = int(max(500.0, min(60000.0, 18000.0 / speed)))

    return f"""// Generated by Modulo (Effect: fractal_flame)
#include <FastLED.h>
#include <math.h>

#define NUM_LEDS {n}
#define LED_PIN {pin}
CRGB leds[NUM_LEDS];

static inline float clamp01(float x) {{
  if (x < 0.0f) return 0.0f;
  if (x > 1.0f) return 1.0f;
  return x;
}}

static inline float lerp(float a, float b, float t) {{
  return a + (b-a)*t;
}}

static inline void palette(uint8_t* r, uint8_t* g, uint8_t* b, float u) {{
  u = clamp01(u);
  if (u < 0.7f) {{
    float tt = u / 0.7f;
    *r = (uint8_t)lerp(0.0f, (float){r0}f, tt);
    *g = (uint8_t)lerp(0.0f, (float){g0}f, tt);
    *b = (uint8_t)lerp(0.0f, (float){b0}f, tt);
  }} else {{
    float tt = (u - 0.7f) / 0.3f;
    *r = (uint8_t)lerp((float){r0}f, 255.0f, tt);
    *g = (uint8_t)lerp((float){g0}f, 255.0f, tt);
    *b = (uint8_t)lerp((float){b0}f, 255.0f, tt);
  }}
}}

void setup() {{
  FastLED.addLeds<WS2812B, LED_PIN, GRB>(leds, NUM_LEDS);
  FastLED.setBrightness(255);
}}

void loop() {{
  unsigned long now = millis();
  float phase = (float)(now % (unsigned long){period_ms}) / (float){period_ms};
  float t = phase;
  float br = clamp01((float){br}f);
  float freq = (float){freq}f;
  float contrast = (float){contrast}f;

  for (int i=0; i<NUM_LEDS; i++) {{
    float x = (NUM_LEDS <= 1) ? 0.0f : ((float)i / (float)(NUM_LEDS - 1));
    float z = x*freq + t*(float){speed}f*0.12f;
    z = z - floorf(z);
    float v = 0.0f;
    for (int k=0; k<{iters}; k++) {{
      z = fmodf(z * (3.2f + 0.6f*sinf(t*0.2f + (float)k)), 1.0f);
      z = fabsf(z*2.0f - 1.0f);
      v += z;
    }}
    v = v / (float){iters}f;
    v = clamp01((v - 0.35f) * contrast + 0.35f);

    uint8_t r,g,b;
    palette(&r,&g,&b,v);
    leds[i] = CRGB((uint8_t)((float)r*br),(uint8_t)((float)g*br),(uint8_t)((float)b*br));
  }}

  FastLED.show();
  delay(1);
}}
"""

def register_fractal_flame():
    return register(BehaviorDef(
        "fractal_flame",
        title="Fractal Flame",
        uses=USES,
        preview_emit=_preview_emit,
        arduino_emit=_arduino_emit,
    ))
