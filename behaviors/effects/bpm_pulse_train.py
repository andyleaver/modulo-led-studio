from __future__ import annotations
SHIPPED = True

from typing import List, Tuple
import math
from behaviors.registry import BehaviorDef, register

RGB=Tuple[int,int,int]
USES=["brightness","speed","softness","density","width"]

def _clamp01(x: float) -> float:
    if x<0.0: return 0.0
    if x>1.0: return 1.0
    return x

def _hsv_to_rgb(h: float, s: float, v: float) -> RGB:
    h=(h%1.0)*6.0
    i=int(h)%6
    f=h-float(i)
    p=v*(1.0-s)
    q=v*(1.0-f*s)
    t=v*(1.0-(1.0-f)*s)
    if i==0: r,g,b=v,t,p
    elif i==1: r,g,b=q,v,p
    elif i==2: r,g,b=p,v,t
    elif i==3: r,g,b=p,q,v
    elif i==4: r,g,b=t,p,v
    else: r,g,b=v,p,q
    return (int(r*255)&255,int(g*255)&255,int(b*255)&255)

def _preview_emit(*, num_leds:int, params:dict, t:float, state=None)->List[RGB]:
    n=max(1,int(num_leds))
    br=_clamp01(float(params.get("brightness",1.0)))
    speed=max(0.1,float(params.get("speed",1.0)))
    softness=_clamp01(float(params.get("softness",0.45)))
    density=_clamp01(float(params.get("density",0.60))) # spacing
    width=_clamp01(float(params.get("width",0.35)))     # thickness
    if width<0.05: width=0.05

    tempo=(params.get("_audio_tempo") or {})
    bpm=float(tempo.get("tempo_bpm",120.0) or 120.0)
    conf=_clamp01(float(tempo.get("tempo_conf",0.0) or 0.0))

    # fallback: use beat if confidence low
    ev=(params.get("_audio_events") or {})
    beat=float(ev.get("beat",0.0) or 0.0)

    if state is None or not isinstance(state, dict):
        state={"phase":0.0, "last_t":t}

    dt=max(0.0, float(t - state.get("last_t", t)))
    state["last_t"]=t

    # advance phase using bpm
    hz=bpm/60.0
    state["phase"]=(state["phase"] + dt*hz) % 1.0

    # if beat exists, snap phase slightly
    if beat>0.5 and conf<0.35:
        state["phase"]=0.02

    # moving pulse positions
    pulses = 3 + int(9*density)
    out=[]
    for i in range(n):
        x=i/max(1.0,(n-1))
        v=0.0
        for k in range(pulses):
            p=(state["phase"] + k/pulses) % 1.0
            d=abs(x-p); d=min(d,1.0-d)
            sig=(0.010 + width*0.06)*(0.7+1.6*softness)
            v += math.exp(-(d*d)/(2.0*sig*sig))
        v = v/(pulses) * (0.25 + 0.75*max(conf, 0.25))
        v = _clamp01(br * v)
        hue = (0.58 + 0.10*math.sin(2*math.pi*(state["phase"])) + 0.10*conf) % 1.0
        out.append(_hsv_to_rgb(hue, 1.0, v))
    return out

def _arduino_emit(*, layout:dict, params:dict)->str:
    # For Arduino we use beat/onset (simpler) to keep stable on MCU.
    n=int(layout["num_leds"]); pin=int(layout["led_pin"])
    br=float(params.get("brightness",1.0))
    speed=max(0.1,float(params.get("speed",1.0)))
    softness=float(params.get("softness",0.45))
    density=float(params.get("density",0.60))
    width=float(params.get("width",0.35))
    if br<0: br=0.0
    if br>1: br=1.0
    if softness<0: softness=0.0
    if softness>1: softness=1.0
    if density<0: density=0.0
    if density>1: density=1.0
    if width<0.05: width=0.05
    if width>1: width=1.0

    alpha=0.10 + 0.35*softness
    sig=(0.010 + width*0.06)*(0.7+1.6*softness)
    pulses = 3 + int(9*density)

    return f"""// Generated by Modulo (BPM Pulse Train - Arduino uses onset/beat)
#include <FastLED.h>
#include <math.h>

#define NUM_LEDS {n}
#define LED_PIN {pin}
CRGB leds[NUM_LEDS];

// MSGEQ7 pins (default)
const int RESET_PIN = 5;
const int STROBE_PIN = 4;
const int LEFT_PIN = A0;
const int RIGHT_PIN = A1;

// mono event state
float mono=0.0f, mono_prev=0.0f, mono_peak=0.0f;
int mono_cd=0;
float phase=0.0f;
unsigned long last_ms=0;

static inline float clamp01(float x) {{
  if (x<0.0f) return 0.0f;
  if (x>1.0f) return 1.0f;
  return x;
}}
static inline float read01(int pin) {{
  int v=analogRead(pin);
  return clamp01((float)v/1023.0f);
}}
static inline void hsv_to_rgb(float h, float s, float v, uint8_t* r, uint8_t* g, uint8_t* b) {{
  float hh=fmodf(h,1.0f)*6.0f;
  int i=(int)floorf(hh)%6;
  float f=hh-(float)i;
  float p=v*(1.0f-s);
  float q=v*(1.0f-f*s);
  float t=v*(1.0f-(1.0f-f)*s);
  float rr,gg,bb;
  if (i==0) {{ rr=v; gg=t; bb=p; }}
  else if (i==1) {{ rr=q; gg=v; bb=p; }}
  else if (i==2) {{ rr=p; gg=v; bb=t; }}
  else if (i==3) {{ rr=p; gg=q; bb=v; }}
  else if (i==4) {{ rr=t; gg=p; bb=v; }}
  else {{ rr=v; gg=p; bb=q; }}
  *r=(uint8_t)(rr*255.0f); *g=(uint8_t)(gg*255.0f); *b=(uint8_t)(bb*255.0f);
}}

void setup() {{
  FastLED.addLeds<WS2812B, LED_PIN, GRB>(leds, NUM_LEDS);
  FastLED.setBrightness(255);
  pinMode(RESET_PIN, OUTPUT);
  pinMode(STROBE_PIN, OUTPUT);
  digitalWrite(RESET_PIN, LOW);
  digitalWrite(STROBE_PIN, HIGH);
  last_ms=millis();
}}

void loop() {{
  // mono energy
  float le=0.0f,re=0.0f;
  digitalWrite(RESET_PIN, HIGH); delayMicroseconds(5); digitalWrite(RESET_PIN, LOW);
  for (int i=0;i<7;i++) {{
    digitalWrite(STROBE_PIN, LOW); delayMicroseconds(30);
    le += read01(LEFT_PIN);
    re += read01(RIGHT_PIN);
    digitalWrite(STROBE_PIN, HIGH);
  }}
  le/=7.0f; re/=7.0f;
  float em=0.5f*(le+re);

  mono_prev=mono;
  mono=(1.0f-{alpha}f)*mono + {alpha}f*em;
  float md=mono-mono_prev;
  mono_peak=fmaxf(mono_peak-0.020f, mono);
  float thr=0.05f + mono_peak*0.20f;

  bool beat=false;
  if (mono_cd>0) mono_cd--;
  else {{
    if (md > thr) {{ beat=true; mono_cd=4; }}
  }}

  unsigned long now=millis();
  float dt=(now-last_ms)/1000.0f;
  last_ms=now;

  // advance phase; beat adds extra impulse
  float hz = (0.6f + 2.0f*mono) * (0.35f + 1.25f*(float){speed}f);
  phase = fmodf(phase + dt*hz, 1.0f);
  if (beat) phase = 0.02f;

  float br=clamp01((float){br}f);
  float conf = clamp01(0.25f + 0.75f*mono_peak);

  for (int i=0;i<NUM_LEDS;i++) {{
    float x=(NUM_LEDS<=1)?0.0f:((float)i/(float)(NUM_LEDS-1));
    float v=0.0f;
    for (int k=0;k<{pulses};k++) {{
      float p=fmodf(phase + (float)k/(float){pulses}, 1.0f);
      float d=fabsf(x-p); d=fminf(d,1.0f-d);
      v += expf(-(d*d)/(2.0f*(float){sig}f*(float){sig}f));
    }}
    v = (v/(float){pulses}) * conf;
    v = clamp01(br*v);
    float hue=fmodf(0.58f + 0.10f*sinf(2.0f*3.1415926f*phase), 1.0f);
    uint8_t r,g,b; hsv_to_rgb(hue,1.0f,v,&r,&g,&b);
    leds[i]=CRGB(r,g,b);
  }}

  FastLED.show();
  delay(1);
}}
"""

def register_bpm_pulse_train():
    return register(BehaviorDef(
        "bpm_pulse_train",
        title="BPM Pulse Train (Tempo)",
        uses=USES,
        preview_emit=_preview_emit,
        arduino_emit=_arduino_emit,
    ))
