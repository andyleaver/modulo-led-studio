from __future__ import annotations
SHIPPED = True

from typing import List, Tuple
import math
from behaviors.registry import BehaviorDef, register
RGB = Tuple[int,int,int]
def _clamp01(x: float) -> float: return 0.0 if x<0.0 else (1.0 if x>1.0 else x)
def _hsv_to_rgb(h: float, s: float, v: float) -> RGB:
    h=(h%1.0)*6.0; i=int(h)%6; f=h-float(i)
    p=v*(1.0-s); q=v*(1.0-f*s); t=v*(1.0-(1.0-f)*s)
    if i==0: r,g,b=v,t,p
    elif i==1: r,g,b=q,v,p
    elif i==2: r,g,b=p,v,t
    elif i==3: r,g,b=p,q,v
    elif i==4: r,g,b=t,p,v
    else: r,g,b=v,p,q
    return (int(r*255)&255,int(g*255)&255,int(b*255)&255)
def _add(a: RGB, b: RGB) -> RGB:
    return (min(255,a[0]+b[0]),min(255,a[1]+b[1]),min(255,a[2]+b[2]))
USES=["brightness","speed","softness","density"]
def _preview_emit(*, num_leds:int, params:dict, t:float, state=None) -> List[RGB]:
    n=max(1,int(num_leds))
    br=_clamp01(float(params.get("brightness",1.0)))
    speed=max(0.1,float(params.get("speed",1.0)))
    softness=_clamp01(float(params.get("softness",0.45)))
    density=_clamp01(float(params.get("density",0.65)))
    audio=params.get("_audio_flat") or {}
    L=[float(audio.get(f"l{i}",0.0) or 0.0) for i in range(7)]
    R=[float(audio.get(f"r{i}",0.0) or 0.0) for i in range(7)]
    lE=sum(L)/7.0; rE=sum(R)/7.0; bass=0.5*(L[0]+R[0]); treb=0.5*(L[6]+R[6])
    if state is None or not isinstance(state, dict): state={"l":lE,"r":rE,"b":bass,"t":treb}
    a=0.05+0.45*softness
    state["l"]=(1.0-a)*state["l"]+a*lE; state["r"]=(1.0-a)*state["r"]+a*rE
    state["b"]=(1.0-a)*state["b"]+a*bass; state["t"]=(1.0-a)*state["t"]+a*treb
    lE,rE,bass,treb=state["l"],state["r"],state["b"],state["t"]
    w=t*(0.35+1.25*speed)*(0.6+1.8*bass)
    out=[]
    for i in range(n):
        x=i/max(1.0,(n-1)); cL=0.25; cR=0.75
        dL=min(abs(x-cL),1.0-abs(x-cL)); dR=min(abs(x-cR),1.0-abs(x-cR))
        sig=(0.08+0.18*density)
        phL=2*math.pi*(x*(2.0+6.0*density)+w*0.7)
        phR=2*math.pi*(x*(2.0+6.0*density)-w*0.65+0.25)
        vL=(0.5+0.5*math.sin(phL))**2.2 * math.exp(-(dL*dL)/(2*sig*sig))*(0.25+0.75*lE)
        vR=(0.5+0.5*math.sin(phR))**2.2 * math.exp(-(dR*dR)/(2*sig*sig))*(0.25+0.75*rE)
        shimmer=0.15+0.85*treb
        vL*= (0.85+0.15*math.sin(2*math.pi*(t*2.1*speed+x*9.0))*shimmer)
        vR*= (0.85+0.15*math.cos(2*math.pi*(t*2.0*speed+x*8.0))*shimmer)
        hueL=(0.80+0.10*math.sin(w*0.15))%1.0
        hueR=(0.55+0.10*math.cos(w*0.16))%1.0
        c1=_hsv_to_rgb(hueL,1.0,1.0); c2=_hsv_to_rgb(hueR,1.0,1.0)
        rr,gg,bb=(0,0,0)
        rr,gg,bb=_add((rr,gg,bb),(int(c1[0]*br*vL),int(c1[1]*br*vL),int(c1[2]*br*vL)))
        rr,gg,bb=_add((rr,gg,bb),(int(c2[0]*br*vR),int(c2[1]*br*vR),int(c2[2]*br*vR)))
        out.append((rr,gg,bb))
    return out
def _arduino_emit(*, layout:dict, params:dict) -> str:
    n=int(layout["num_leds"]); pin=int(layout["led_pin"])
    br=max(0.0,min(1.0,float(params.get("brightness",1.0))))
    speed=max(0.1,float(params.get("speed",1.0)))
    softness=max(0.0,min(1.0,float(params.get("softness",0.45))))
    density=max(0.0,min(1.0,float(params.get("density",0.65))))
    alpha=0.05+0.45*softness
    return f"""// Generated by Modulo (Stereo Dual Vortex)
#include <FastLED.h>
#include <math.h>
#define NUM_LEDS {n}
#define LED_PIN {pin}
CRGB leds[NUM_LEDS];
const int RESET_PIN=5, STROBE_PIN=4, LEFT_PIN=A0, RIGHT_PIN=A1;
float lE=0.0f,rE=0.0f,bass=0.0f,treb=0.0f;
static inline float clamp01(float x){{return x<0?0:(x>1?1:x);}}
static inline float read01(int pin){{return clamp01((float)analogRead(pin)/1023.0f);}}
static inline void hsv_to_rgb(float h,float s,float v,uint8_t* r,uint8_t* g,uint8_t* b){{
  float hh=fmodf(h,1.0f)*6.0f; int i=(int)floorf(hh)%6; float f=hh-(float)i;
  float p=v*(1.0f-s), q=v*(1.0f-f*s), t=v*(1.0f-(1.0f-f)*s); float rr,gg,bb;
  if(i==0){{rr=v;gg=t;bb=p;}} else if(i==1){{rr=q;gg=v;bb=p;}} else if(i==2){{rr=p;gg=v;bb=t;}}
  else if(i==3){{rr=p;gg=q;bb=v;}} else if(i==4){{rr=t;gg=p;bb=v;}} else {{rr=v;gg=p;bb=q;}}
  *r=(uint8_t)(rr*255.0f);*g=(uint8_t)(gg*255.0f);*b=(uint8_t)(bb*255.0f);
}}
static inline void add_rgb(uint8_t* r,uint8_t* g,uint8_t* b,float ar,float ag,float ab){{
  *r=(uint8_t)fminf(255.0f,(float)(*r)+ar); *g=(uint8_t)fminf(255.0f,(float)(*g)+ag); *b=(uint8_t)fminf(255.0f,(float)(*b)+ab);
}}
void setup(){{
  FastLED.addLeds<WS2812B, LED_PIN, GRB>(leds, NUM_LEDS); FastLED.setBrightness(255);
  pinMode(RESET_PIN,OUTPUT); pinMode(STROBE_PIN,OUTPUT); digitalWrite(RESET_PIN,LOW); digitalWrite(STROBE_PIN,HIGH);
}}
void loop(){{
  float L[7],R[7];
  digitalWrite(RESET_PIN,HIGH); delayMicroseconds(5); digitalWrite(RESET_PIN,LOW);
  for(int i=0;i<7;i++){{ digitalWrite(STROBE_PIN,LOW); delayMicroseconds(30); L[i]=read01(LEFT_PIN); R[i]=read01(RIGHT_PIN); digitalWrite(STROBE_PIN,HIGH); }}
  float le=0,re=0; for(int i=0;i<7;i++){{le+=L[i];re+=R[i];}} le/=7.0f; re/=7.0f;
  float b=0.5f*(L[0]+R[0]); float tr=0.5f*(L[6]+R[6]);
  lE=(1.0f-{alpha}f)*lE+{alpha}f*le; rE=(1.0f-{alpha}f)*rE+{alpha}f*re;
  bass=(1.0f-{alpha}f)*bass+{alpha}f*b; treb=(1.0f-{alpha}f)*treb+{alpha}f*tr;
  float br=clamp01((float){br}f); float speed=(float){speed}f; float density=clamp01((float){density}f);
  float tt=millis()/1000.0f; float w=tt*(0.35f+1.25f*speed)*(0.6f+1.8f*bass);
  for(int i=0;i<NUM_LEDS;i++){{ float x=(NUM_LEDS<=1)?0.0f:((float)i/(float)(NUM_LEDS-1));
    float cL=0.25f,cR=0.75f; float dL=fabsf(x-cL); dL=fminf(dL,1.0f-dL); float dR=fabsf(x-cR); dR=fminf(dR,1.0f-dR);
    float sig=(0.08f+0.18f*density);
    float phL=2.0f*3.1415926f*(x*(2.0f+6.0f*density)+w*0.7f);
    float phR=2.0f*3.1415926f*(x*(2.0f+6.0f*density)-w*0.65f+0.25f);
    float vL=powf(0.5f+0.5f*sinf(phL),2.2f)*expf(-(dL*dL)/(2.0f*sig*sig))*(0.25f+0.75f*lE);
    float vR=powf(0.5f+0.5f*sinf(phR),2.2f)*expf(-(dR*dR)/(2.0f*sig*sig))*(0.25f+0.75f*rE);
    float shimmer=0.15f+0.85f*treb;
    vL*=(0.85f+0.15f*sinf(2.0f*3.1415926f*(tt*2.1f*speed+x*9.0f))*shimmer);
    vR*=(0.85f+0.15f*cosf(2.0f*3.1415926f*(tt*2.0f*speed+x*8.0f))*shimmer);
    float hueL=fmodf(0.80f+0.10f*sinf(w*0.15f),1.0f);
    float hueR=fmodf(0.55f+0.10f*cosf(w*0.16f),1.0f);
    uint8_t r=0,g=0,b0=0,r1,g1,b1,r2,g2,b2; hsv_to_rgb(hueL,1.0f,1.0f,&r1,&g1,&b1); hsv_to_rgb(hueR,1.0f,1.0f,&r2,&g2,&b2);
    add_rgb(&r,&g,&b0,(float)r1*br*vL,(float)g1*br*vL,(float)b1*br*vL); add_rgb(&r,&g,&b0,(float)r2*br*vR,(float)g2*br*vR,(float)b2*br*vR);
    leds[i]=CRGB(r,g,b0);
  }}
  FastLED.show(); delay(1);
}}
"""
def register_stereo_dual_vortex():
    return register(BehaviorDef("stereo_dual_vortex", title="Stereo Dual Vortex", uses=USES, preview_emit=_preview_emit, arduino_emit=_arduino_emit))
