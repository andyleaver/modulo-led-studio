from __future__ import annotations
SHIPPED = True

from typing import List, Tuple
import math

from behaviors.registry import BehaviorDef, register

RGB = Tuple[int,int,int]

def _clamp01(x: float) -> float:
    if x < 0.0: return 0.0
    if x > 1.0: return 1.0
    return x

def _apply_brightness(rgb: RGB, br: float) -> RGB:
    br = _clamp01(float(br))
    r,g,b = rgb
    return (int(r*br)&255, int(g*br)&255, int(b*br)&255)

def _preview_emit(*, num_leds: int, params: dict, t: float, state=None) -> List[RGB]:
    n = max(1, int(num_leds))
    col = params.get("color", (255, 0, 0))
    br = params.get("brightness", 1.0)
    speed = float(params.get("speed", 1.0))
    # Width semantics: support both legacy fraction (<=1.0) and pixel width (>1.0)
    try:
        width_in = float(params.get("width", 12.0))
    except Exception:
        width_in = 12.0
    softness = _clamp01(float(params.get("softness", 0.0)))
    # Some projects store direction as a string ("forward"/"backward") via
    # ALWAYS_KEYS. Normalize so the effect doesn't throw and render black.
    direction_raw = params.get("direction", 1.0)
    if isinstance(direction_raw, str):
        dr = direction_raw.strip().lower()
        if dr in ("forward", "fwd", "+", "1", "true", "yes"):
            direction = 1.0
        elif dr in ("backward", "back", "bwd", "-", "-1", "false", "no"):
            direction = -1.0
        else:
            try:
                direction = float(direction_raw)
            except Exception:
                direction = 1.0
    else:
        direction = float(direction_raw)

    base = _apply_brightness((int(col[0])&255, int(col[1])&255, int(col[2])&255), br)

    # scanner position (0..1..0 triangle wave)
    phase = (t * max(0.0, speed)) % 1.0
    tri = 1.0 - abs(2.0*phase - 1.0)  # 0..1..0
    pos01 = tri if direction >= 0.0 else (1.0 - tri)
    pos = pos01 * (n - 1)

    # beam half-width in LEDs
    if width_in <= 1.0:
        width_px = int(round(max(0.01, width_in) * n))
    else:
        width_px = int(round(width_in))
    if width_px < 1:
        width_px = 1
    if width_px > n:
        width_px = n
    halfw = max(0.5, float(width_px) * 0.5)

    out: List[RGB] = []
    for i in range(n):
        d = abs(i - pos)
        if d <= halfw:
            # linear falloff; softness widens falloff region
            # softness=0 -> hard edge (step), softness=1 -> smooth
            if softness <= 0.001:
                a = 1.0
            else:
                # map distance to 0..1 across halfw; apply smoothstep
                x = _clamp01(1.0 - (d / halfw))
                # soften: blend between hard and smoothstep
                smooth = x*x*(3.0 - 2.0*x)
                a = (1.0 - softness) * (1.0 if x > 0.0 else 0.0) + softness * smooth
            out.append((int(base[0]*a)&255, int(base[1]*a)&255, int(base[2]*a)&255))
        else:
            out.append((0,0,0))
    return out

def _arduino_emit(*, layout: dict, params: dict) -> str:
    n = int(layout["num_leds"])
    pin = int(layout["led_pin"])
    col = params.get("color", (255,0,0))
    br = float(params.get("brightness", 1.0))
    speed = float(params.get("speed", 1.0))
    width_in = float(params.get("width", 12.0))
    softness = float(params.get("softness", 0.0))
    # Some projects store direction as a string ("forward"/"backward") via
    # ALWAYS_KEYS. Normalize so the effect doesn't throw and render black.
    direction_raw = params.get("direction", 1.0)
    if isinstance(direction_raw, str):
        dr = direction_raw.strip().lower()
        if dr in ("forward", "fwd", "+", "1", "true", "yes"):
            direction = 1.0
        elif dr in ("backward", "back", "bwd", "-", "-1", "false", "no"):
            direction = -1.0
        else:
            try:
                direction = float(direction_raw)
            except Exception:
                direction = 1.0
    else:
        direction = float(direction_raw)

    if br < 0.0: br = 0.0
    if br > 1.0: br = 1.0
    # width: legacy fraction (<=1.0) or pixels (>1.0)
    if width_in <= 1.0:
        width_px = int(round(max(0.01, width_in) * n))
    else:
        width_px = int(round(width_in))
    if width_px < 1: width_px = 1
    if width_px > n: width_px = n
    if softness < 0.0: softness = 0.0
    if softness > 1.0: softness = 1.0

    r = int(int(col[0]) * br) & 255
    g = int(int(col[1]) * br) & 255
    b = int(int(col[2]) * br) & 255

    # speed -> cycle time: higher speed = faster. cycle_ms in [200..4000]
    cycle_ms = int(max(200.0, min(4000.0, 2000.0 / max(0.2, speed))))
    halfw = max(1.0, float(width_px) * 0.5)

    return f"""// Generated by Modulo (Effect: scanner)
#include <FastLED.h>

#define NUM_LEDS {n}
#define LED_PIN {pin}
CRGB leds[NUM_LEDS];

static inline float clamp01(float x) {{
  if (x < 0.0f) return 0.0f;
  if (x > 1.0f) return 1.0f;
  return x;
}}

static inline float smoothstep(float x) {{
  x = clamp01(x);
  return x*x*(3.0f - 2.0f*x);
}}

void setup() {{
  FastLED.addLeds<WS2812B, LED_PIN, GRB>(leds, NUM_LEDS);
  FastLED.setBrightness(255);
}}

void loop() {{
  unsigned long now = millis();
  float phase = (float)(now % (unsigned long){cycle_ms}) / (float){cycle_ms}; // 0..1
  float tri = 1.0f - fabsf(2.0f*phase - 1.0f); // 0..1..0
  float pos01 = ({direction}f >= 0.0f) ? tri : (1.0f - tri);
  float pos = pos01 * (float)(NUM_LEDS - 1);

  for (int i=0; i<NUM_LEDS; i++) {{
    float d = fabsf((float)i - pos);
    if (d <= (float){halfw}f) {{
      float x = 1.0f - (d / (float){halfw}f); // 0..1
      float s = smoothstep(x);
      float a = (1.0f - (float){softness}f) * ((x > 0.0f) ? 1.0f : 0.0f) + (float){softness}f * s;
      leds[i] = CRGB((uint8_t)({r}f*a), (uint8_t)({g}f*a), (uint8_t)({b}f*a));
    }} else {{
      leds[i] = CRGB(0,0,0);
    }}
  }}

  FastLED.show();
}}
"""

def register_scanner():
    return register(BehaviorDef(
        "scanner",
        title="Scanner / Sweep",
        uses=["color","brightness","speed","width","softness","direction"],
        preview_emit=_preview_emit,
        arduino_emit=_arduino_emit,
    ))


def register_sweep():
    """Alias for older UI builds that refer to 'sweep'.

    We keep the UI-friendly name 'Sweep' but reuse the same implementation as Scanner.
    """
    bd = BehaviorDef(
        "sweep",
        title="Sweep",
        uses=["color","brightness","speed","width","softness","direction"],
        preview_emit=_preview_emit,
        arduino_emit=_arduino_emit,
    )
    return register(bd)
