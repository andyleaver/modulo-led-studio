from __future__ import annotations
SHIPPED = True

from typing import List, Tuple
import math

from behaviors.registry import BehaviorDef, register

RGB = Tuple[int,int,int]

def _clamp01(x: float) -> float:
    if x < 0.0: return 0.0
    if x > 1.0: return 1.0
    return x

def _apply_brightness(rgb: RGB, br: float) -> RGB:
    br = _clamp01(float(br))
    r,g,b = rgb
    return (int(r*br)&255, int(g*br)&255, int(b*br)&255)

def _hash_u32(x: int) -> int:
    x = (x ^ 0x9E3779B9) & 0xFFFFFFFF
    x = (x * 0x85EBCA6B) & 0xFFFFFFFF
    x = (x ^ (x >> 13)) & 0xFFFFFFFF
    x = (x * 0xC2B2AE35) & 0xFFFFFFFF
    x = (x ^ (x >> 16)) & 0xFFFFFFFF
    return x

def _u01(h: int) -> float:
    return float(h & 0xFFFFFF) / float(0x1000000)

def _hsv_to_rgb(h: float, s: float, v: float) -> RGB:
    h = (h % 1.0) * 6.0
    i = int(h) % 6
    f = h - float(i)
    p = v * (1.0 - s)
    q = v * (1.0 - f * s)
    t = v * (1.0 - (1.0 - f) * s)
    if i == 0: r,g,b = v,t,p
    elif i == 1: r,g,b = q,v,p
    elif i == 2: r,g,b = p,v,t
    elif i == 3: r,g,b = p,q,v
    elif i == 4: r,g,b = t,p,v
    else: r,g,b = v,p,q
    return (int(r*255)&255, int(g*255)&255, int(b*255)&255)

USES = ["brightness","speed","density","softness","color"]

def _preview_emit(*, num_leds: int, params: dict, t: float) -> List[RGB]:
    n = max(1, int(num_leds))
    br = float(params.get("brightness", 1.0))
    speed = float(params.get("speed", 1.0))
    density = _clamp01(float(params.get("density", 0.15)))
    softness = _clamp01(float(params.get("softness", 0.35)))  # decay length
    tint = params.get("color", (255,255,255))
    tint_rgb = (int(tint[0])&255, int(tint[1])&255, int(tint[2])&255)

    # "events" per second (bucketed so deterministic)
    eps = max(0.1, speed) * 6.0
    bucket = int(t * eps)
    u = (t * eps) - float(bucket)  # 0..1 inside bucket
    # decay: softness maps to longer decay
    decay = 0.15 + softness * 0.55
    a = max(0.0, 1.0 - (u / decay)) if u <= decay else 0.0
    a = a*a

    out = [(0,0,0) for _ in range(n)]
    # number of sparkles this bucket
    k = max(1, int(round(density * max(1, n//4))))
    for j in range(k):
        h = _hash_u32(bucket * 131 + j * 911)
        idx = int(_u01(h) * n) % n
        hue = _u01(_hash_u32(h ^ 0x1234567))  # 0..1
        rgb = _hsv_to_rgb(hue, 1.0, 1.0)
        # apply tint as multiply (keeps user color influence)
        rgb = (rgb[0] * tint_rgb[0] // 255, rgb[1] * tint_rgb[1] // 255, rgb[2] * tint_rgb[2] // 255)
        rgb = _apply_brightness(rgb, br * a)
        out[idx] = rgb
    return out

def _arduino_emit(*, layout: dict, params: dict) -> str:
    n = int(layout["num_leds"])
    pin = int(layout["led_pin"])
    br = float(params.get("brightness", 1.0))
    speed = float(params.get("speed", 1.0))
    density = float(params.get("density", 0.15))
    softness = float(params.get("softness", 0.35))
    tint = params.get("color",(255,255,255))

    if br < 0.0: br = 0.0
    if br > 1.0: br = 1.0
    if density < 0.0: density = 0.0
    if density > 1.0: density = 1.0
    if softness < 0.0: softness = 0.0
    if softness > 1.0: softness = 1.0

    tr = int(tint[0]) & 255
    tg = int(tint[1]) & 255
    tb = int(tint[2]) & 255

    eps = max(0.1, speed) * 6.0
    bucket_ms = int(max(40.0, min(2000.0, 1000.0 / eps)))
    decay = 0.15 + softness * 0.55
    decay_ms = int(max(20.0, float(bucket_ms) * decay))
    k = int(max(1.0, round(density * max(1.0, float(n)/4.0))))

    return f"""// Generated by Modulo (Effect: confetti)
#include <FastLED.h>
#include <math.h>

#define NUM_LEDS {n}
#define LED_PIN {pin}
CRGB leds[NUM_LEDS];

static inline uint32_t hash_u32(uint32_t x) {{
  x ^= 0x9E3779B9u;
  x *= 0x85EBCA6Bu;
  x ^= (x >> 13);
  x *= 0xC2B2AE35u;
  x ^= (x >> 16);
  return x;
}}

static inline float u01(uint32_t h) {{
  return (float)(h & 0xFFFFFFu) / 16777216.0f;
}}

static inline void hsv_to_rgb(float h, float s, float v, uint8_t* r, uint8_t* g, uint8_t* b) {{
  float hh = fmodf(h, 1.0f) * 6.0f;
  int i = (int)floorf(hh) % 6;
  float f = hh - (float)i;
  float p = v * (1.0f - s);
  float q = v * (1.0f - f * s);
  float t = v * (1.0f - (1.0f - f) * s);
  float rr,gg,bb;
  if (i==0) {{ rr=v; gg=t; bb=p; }}
  else if (i==1) {{ rr=q; gg=v; bb=p; }}
  else if (i==2) {{ rr=p; gg=v; bb=t; }}
  else if (i==3) {{ rr=p; gg=q; bb=v; }}
  else if (i==4) {{ rr=t; gg=p; bb=v; }}
  else {{ rr=v; gg=p; bb=q; }}
  *r = (uint8_t)(rr*255.0f);
  *g = (uint8_t)(gg*255.0f);
  *b = (uint8_t)(bb*255.0f);
}}

void setup() {{
  FastLED.addLeds<WS2812B, LED_PIN, GRB>(leds, NUM_LEDS);
  FastLED.setBrightness(255);
}}

void loop() {{
  unsigned long now = millis();
  unsigned long bucket = now / (unsigned long){bucket_ms};
  float u = (float)(now % (unsigned long){bucket_ms}) / (float){bucket_ms};

  // decay inside bucket
  float a = 0.0f;
  float ms = u * (float){bucket_ms};
  if (ms <= (float){decay_ms}) {{
    float x = 1.0f - (ms / (float){decay_ms});
    a = x * x;
  }}

  // clear
  for (int i=0; i<NUM_LEDS; i++) leds[i] = CRGB(0,0,0);

  for (int j=0; j<{k}; j++) {{
    uint32_t h = hash_u32((uint32_t)bucket * 131u + (uint32_t)j * 911u);
    int idx = (int)(u01(h) * (float)NUM_LEDS) % NUM_LEDS;
    float hue = u01(hash_u32(h ^ 0x01234567u));
    uint8_t r,g,b;
    hsv_to_rgb(hue, 1.0f, 1.0f, &r, &g, &b);

    // tint multiply
    r = (uint8_t)((uint16_t)r * (uint16_t){tr} / 255u);
    g = (uint8_t)((uint16_t)g * (uint16_t){tg} / 255u);
    b = (uint8_t)((uint16_t)b * (uint16_t){tb} / 255u);

    float br = (float){br}f * a;
    r = (uint8_t)((float)r * br);
    g = (uint8_t)((float)g * br);
    b = (uint8_t)((float)b * br);

    leds[idx] = CRGB(r,g,b);
  }}

  FastLED.show();
  delay(1);
}}
"""

def register_confetti():
    return register(BehaviorDef(
        "confetti",
        title="Confetti / Glitter",
        uses=USES,
        preview_emit=_preview_emit,
        arduino_emit=_arduino_emit,
    ))
