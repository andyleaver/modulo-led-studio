from __future__ import annotations
SHIPPED = True

from typing import List, Tuple
import math

from behaviors.registry import BehaviorDef, register

RGB = Tuple[int,int,int]

def _clamp01(x: float) -> float:
    if x < 0.0: return 0.0
    if x > 1.0: return 1.0
    return x

def _lerp(a: float, b: float, t: float) -> float:
    return a + (b-a)*t

def _hash_u32(x: int) -> int:
    x = (x ^ 0x9E3779B9) & 0xFFFFFFFF
    x = (x * 0x85EBCA6B) & 0xFFFFFFFF
    x = (x ^ (x >> 13)) & 0xFFFFFFFF
    x = (x * 0xC2B2AE35) & 0xFFFFFFFF
    x = (x ^ (x >> 16)) & 0xFFFFFFFF
    return x

def _u01(h: int) -> float:
    return float(h & 0xFFFFFF) / float(0x1000000)

def _hsv_to_rgb(h: float, s: float, v: float) -> RGB:
    h = (h % 1.0) * 6.0
    i = int(h) % 6
    f = h - float(i)
    p = v * (1.0 - s)
    q = v * (1.0 - f * s)
    t = v * (1.0 - (1.0 - f) * s)
    if i == 0: r,g,b = v,t,p
    elif i == 1: r,g,b = q,v,p
    elif i == 2: r,g,b = p,v,t
    elif i == 3: r,g,b = p,q,v
    elif i == 4: r,g,b = t,p,v
    else: r,g,b = v,p,q
    return (int(r*255)&255, int(g*255)&255, int(b*255)&255)

USES = ["brightness","speed","density","softness","width"]

def _preview_emit(*, num_leds: int, params: dict, t: float) -> List[RGB]:
    # Stateless RD-style: compute a short iterative relaxation per frame from analytic seeds.
    n = max(1, int(num_leds))
    br = _clamp01(float(params.get("brightness", 1.0)))
    speed = max(0.1, float(params.get("speed", 1.0)))
    density = _clamp01(float(params.get("density", 0.55)))   # seed count
    softness = _clamp01(float(params.get("softness", 0.55))) # smoothness / diffusion
    width = _clamp01(float(params.get("width", 0.45)))       # reaction strength
    if width < 0.05: width = 0.05

    seeds = 2 + int(round(density*6.0))    # 2..8
    steps = 6 + int(round(softness*14.0))  # 6..20
    diff = 0.12 + softness*0.38
    react = 0.45 + width*0.9

    # Initial fields U,V from moving seeds
    U = [1.0 for _ in range(n)]
    V = [0.0 for _ in range(n)]
    for s in range(seeds):
        h = _hash_u32(s*733 + int(t*speed*2.0))
        c = _u01(h)
        w = 0.05 + 0.12*_u01(_hash_u32(h ^ 0xBEEF))
        for i in range(n):
            x = i / max(1.0,(n-1))
            d = abs(x - c)
            d = min(d, 1.0-d)
            a = math.exp(-(d*d)/(2.0*w*w))
            V[i] += 0.9*a
            U[i] -= 0.6*a

    # Clamp
    for i in range(n):
        U[i] = _clamp01(U[i])
        V[i] = _clamp01(V[i])

    # Iterate a few steps (Euler) with wraparound Laplacian
    for _ in range(steps):
        U2 = U[:]
        V2 = V[:]
        for i in range(n):
            im = (i-1) % n
            ip = (i+1) % n
            lapU = U[im] - 2.0*U[i] + U[ip]
            lapV = V[im] - 2.0*V[i] + V[ip]
            u = U[i]
            v = V[i]
            # Gray-Scott-ish
            du = diff*lapU - u*(v*v) + (0.055*(1.0-u))
            dv = diff*lapV + u*(v*v) - (0.062+0.02*react)*v
            U2[i] = _clamp01(u + du*0.9)
            V2[i] = _clamp01(v + dv*0.9)
        U, V = U2, V2

    out=[]
    for i in range(n):
        v = V[i]
        hue = (0.62 + 0.25*v + t*speed*0.03) % 1.0
        r,g,b = _hsv_to_rgb(hue, 1.0, br*(0.05 + 0.95*v))
        out.append((r,g,b))
    return out

def _arduino_emit(*, layout: dict, params: dict) -> str:
    n = int(layout["num_leds"])
    pin = int(layout["led_pin"])
    br = float(params.get("brightness", 1.0))
    speed = max(0.1, float(params.get("speed", 1.0)))
    density = float(params.get("density", 0.55))
    softness = float(params.get("softness", 0.55))
    width = float(params.get("width", 0.45))

    # clamp
    br = 0.0 if br < 0.0 else (1.0 if br > 1.0 else br)
    density = 0.0 if density < 0.0 else (1.0 if density > 1.0 else density)
    softness = 0.0 if softness < 0.0 else (1.0 if softness > 1.0 else softness)
    if width < 0.05: width = 0.05
    if width > 1.0: width = 1.0

    seeds = 2 + int(round(density*6.0))
    steps = 6 + int(round(softness*14.0))
    diff = 0.12 + softness*0.38
    react = 0.45 + width*0.9
    period_ms = int(max(450.0, min(60000.0, 22000.0 / speed)))

    return f"""// Generated by Modulo (Effect: reaction_diffusion)
#include <FastLED.h>
#include <math.h>

#define NUM_LEDS {n}
#define LED_PIN {pin}
CRGB leds[NUM_LEDS];

static inline float clamp01(float x) {{
  if (x < 0.0f) return 0.0f;
  if (x > 1.0f) return 1.0f;
  return x;
}}

static inline uint32_t hash_u32(uint32_t x) {{
  x ^= 0x9E3779B9u;
  x *= 0x85EBCA6Bu;
  x ^= (x >> 13);
  x *= 0xC2B2AE35u;
  x ^= (x >> 16);
  return x;
}}

static inline float u01(uint32_t h) {{
  return (float)(h & 0xFFFFFFu) / 16777216.0f;
}}

static inline void hsv_to_rgb(float h, float s, float v, uint8_t* r, uint8_t* g, uint8_t* b) {{
  float hh = fmodf(h, 1.0f) * 6.0f;
  int i = (int)floorf(hh) % 6;
  float f = hh - (float)i;
  float p = v * (1.0f - s);
  float q = v * (1.0f - f * s);
  float t = v * (1.0f - (1.0f - f) * s);
  float rr,gg,bb;
  if (i==0) {{ rr=v; gg=t; bb=p; }}
  else if (i==1) {{ rr=q; gg=v; bb=p; }}
  else if (i==2) {{ rr=p; gg=v; bb=t; }}
  else if (i==3) {{ rr=p; gg=q; bb=v; }}
  else if (i==4) {{ rr=t; gg=p; bb=v; }}
  else {{ rr=v; gg=p; bb=q; }}
  *r = (uint8_t)(rr*255.0f);
  *g = (uint8_t)(gg*255.0f);
  *b = (uint8_t)(bb*255.0f);
}}

void setup() {{
  FastLED.addLeds<WS2812B, LED_PIN, GRB>(leds, NUM_LEDS);
  FastLED.setBrightness(255);
}}

void loop() {{
  unsigned long now = millis();
  float phase = (float)(now % (unsigned long){period_ms}) / (float){period_ms};
  float t = phase;

  float br = clamp01((float){br}f);
  float density = clamp01((float){density}f);
  float softness = clamp01((float){softness}f);

  const int seeds = {seeds};
  const int steps = {steps};
  const float diff = (float){diff}f;
  const float react = (float){react}f;

  static float U[NUM_LEDS];
  static float V[NUM_LEDS];
  static float U2[NUM_LEDS];
  static float V2[NUM_LEDS];

  // init fields from analytic seeds (per frame)
  for (int i=0; i<NUM_LEDS; i++) {{ U[i]=1.0f; V[i]=0.0f; }}

  int seed_bucket = (int)floorf(t*(float){speed}f*2.0f);
  for (int s=0; s<seeds; s++) {{
    uint32_t h = hash_u32((uint32_t)(s*733 + seed_bucket));
    float c = u01(h);
    float w = 0.05f + 0.12f*u01(hash_u32(h ^ 0x0000BEEFu));
    for (int i=0; i<NUM_LEDS; i++) {{
      float x = (NUM_LEDS<=1)?0.0f:((float)i/(float)(NUM_LEDS-1));
      float d = fabsf(x - c);
      d = fminf(d, 1.0f - d);
      float a = expf(-(d*d)/(2.0f*w*w));
      V[i] += 0.9f*a;
      U[i] -= 0.6f*a;
    }}
  }}

  for (int i=0; i<NUM_LEDS; i++) {{
    U[i]=clamp01(U[i]);
    V[i]=clamp01(V[i]);
  }}

  // iterate a few steps
  for (int st=0; st<steps; st++) {{
    for (int i=0; i<NUM_LEDS; i++) {{
      int im = (i-1+NUM_LEDS)%NUM_LEDS;
      int ip = (i+1)%NUM_LEDS;
      float lapU = U[im] - 2.0f*U[i] + U[ip];
      float lapV = V[im] - 2.0f*V[i] + V[ip];
      float u = U[i];
      float v = V[i];
      float du = diff*lapU - u*(v*v) + (0.055f*(1.0f-u));
      float dv = diff*lapV + u*(v*v) - (0.062f+0.02f*react)*v;
      U2[i] = clamp01(u + du*0.9f);
      V2[i] = clamp01(v + dv*0.9f);
    }}
    for (int i=0; i<NUM_LEDS; i++) {{ U[i]=U2[i]; V[i]=V2[i]; }}
  }}

  for (int i=0; i<NUM_LEDS; i++) {{
    float v = V[i];
    float hue = fmodf(0.62f + 0.25f*v + t*(float){speed}f*0.03f, 1.0f);
    uint8_t r,g,b;
    hsv_to_rgb(hue, 1.0f, br*(0.05f + 0.95f*v), &r,&g,&b);
    leds[i] = CRGB(r,g,b);
  }}

  FastLED.show();
  delay(1);
}}
"""

def register_reaction_diffusion():
    return register(BehaviorDef(
        "reaction_diffusion",
        title="Reaction Diffusion",
        uses=USES,
        preview_emit=_preview_emit,
        arduino_emit=_arduino_emit,
    ))
