from __future__ import annotations
SHIPPED = True

from typing import List, Tuple
import math
from behaviors.registry import BehaviorDef, register
RGB = Tuple[int,int,int]
def _clamp01(x: float) -> float:
    return 0.0 if x<0.0 else (1.0 if x>1.0 else x)
def _hsv_to_rgb(h: float, s: float, v: float) -> RGB:
    h=(h%1.0)*6.0; i=int(h)%6; f=h-float(i)
    p=v*(1.0-s); q=v*(1.0-f*s); t=v*(1.0-(1.0-f)*s)
    if i==0: r,g,b=v,t,p
    elif i==1: r,g,b=q,v,p
    elif i==2: r,g,b=p,v,t
    elif i==3: r,g,b=p,q,v
    elif i==4: r,g,b=t,p,v
    else: r,g,b=v,p,q
    return (int(r*255)&255,int(g*255)&255,int(b*255)&255)
def _add(a: RGB, b: RGB) -> RGB:
    return (min(255,a[0]+b[0]),min(255,a[1]+b[1]),min(255,a[2]+b[2]))
USES=["brightness","speed","softness","width","density"]
def _preview_emit(*, num_leds:int, params:dict, t:float, state=None) -> List[RGB]:
    n=max(1,int(num_leds))
    br=_clamp01(float(params.get("brightness",1.0)))
    speed=max(0.1,float(params.get("speed",1.0)))
    softness=_clamp01(float(params.get("softness",0.45)))
    width=_clamp01(float(params.get("width",0.35))); width=max(width,0.05)
    density=_clamp01(float(params.get("density",0.60)))
    audio=params.get("_audio_flat") or {}
    bands=[float(audio.get(f"l{i}",0.0) or 0.0) for i in range(7)] + [float(audio.get(f"r{i}",0.0) or 0.0) for i in range(7)]
    if state is None or not isinstance(state, dict): state={"b":[0.0]*14}
    a=0.05+0.45*softness
    for i in range(14):
        v=max(0.0,min(1.0,bands[i])); state["b"][i]=(1.0-a)*state["b"][i]+a*v
    b=state["b"]
    bass=0.5*(b[0]+b[7]); mid=(b[3]+b[4]+b[10]+b[11])*0.25; treb=0.5*(b[6]+b[13])
    rot=t*(0.25+1.25*speed)*(0.6+1.8*bass)
    twist=2.0+6.0*density
    spine=0.5+0.18*math.sin(t*0.35*speed+3.0*bass)
    rad=0.20+0.25*(0.25+mid)+0.08*math.sin(t*0.6*speed)
    sig=(0.010+width*0.045)*(0.8+1.6*softness)
    out=[(0,0,0) for _ in range(n)]
    for px in range(n):
        x=px/max(1.0,(n-1))
        ang=2*math.pi*(x*twist+rot)
        y1=spine+rad*math.sin(ang); y2=spine-rad*math.sin(ang)
        d1=min(abs(x-y1),1.0-abs(x-y1)); d2=min(abs(x-y2),1.0-abs(x-y2))
        a1=math.exp(-(d1*d1)/(2.0*sig*sig)); a2=math.exp(-(d2*d2)/(2.0*sig*sig))
        rung=0.5+0.5*math.sin(2*math.pi*(x*(3.0+6.0*density)-rot*0.6))
        rung=(rung**2.5)*(0.15+0.85*treb)
        hue1=(0.62+0.28*x+0.06*math.sin(ang))%1.0
        hue2=(0.18+0.28*(1.0-x)+0.06*math.cos(ang))%1.0
        c1=_hsv_to_rgb(hue1,1.0,1.0); c2=_hsv_to_rgb(hue2,1.0,1.0)
        v1=br*(0.06+0.94*a1*(0.35+0.65*(0.3+bass)))
        v2=br*(0.06+0.94*a2*(0.35+0.65*(0.3+mid)))
        rr,gg,bb=(0,0,0)
        rr,gg,bb=_add((rr,gg,bb),(int(c1[0]*v1),int(c1[1]*v1),int(c1[2]*v1)))
        rr,gg,bb=_add((rr,gg,bb),(int(c2[0]*v2),int(c2[1]*v2),int(c2[2]*v2)))
        rung_v=br*(0.18*rung)*(0.4+0.6*(bass+mid))
        if rung_v>0.001: rr,gg,bb=_add((rr,gg,bb),(int(255*rung_v),int(210*rung_v),int(255*rung_v)))
        out[px]=(rr,gg,bb)
    return out
def _arduino_emit(*, layout:dict, params:dict) -> str:
    n=int(layout["num_leds"]); pin=int(layout["led_pin"])
    br=float(params.get("brightness",1.0)); br=max(0.0,min(1.0,br))
    speed=max(0.1,float(params.get("speed",1.0)))
    softness=max(0.0,min(1.0,float(params.get("softness",0.45))))
    width=max(0.05,min(1.0,float(params.get("width",0.35))))
    density=max(0.0,min(1.0,float(params.get("density",0.60))))
    alpha=0.05+0.45*softness
    return f"""// Generated by Modulo (Spectral DNA Helix 14)
#include <FastLED.h>
#include <math.h>
#define NUM_LEDS {n}
#define LED_PIN {pin}
CRGB leds[NUM_LEDS];
const int RESET_PIN=5, STROBE_PIN=4, LEFT_PIN=A0, RIGHT_PIN=A1;
float B[14]={{0}};
static inline float clamp01(float x){{ return x<0?0:(x>1?1:x); }}
static inline float read01(int pin){{ return clamp01((float)analogRead(pin)/1023.0f); }}
static inline void hsv_to_rgb(float h,float s,float v,uint8_t* r,uint8_t* g,uint8_t* b){{
  float hh=fmodf(h,1.0f)*6.0f; int i=(int)floorf(hh)%6; float f=hh-(float)i;
  float p=v*(1.0f-s), q=v*(1.0f-f*s), t=v*(1.0f-(1.0f-f)*s); float rr,gg,bb;
  if(i==0){{rr=v;gg=t;bb=p;}} else if(i==1){{rr=q;gg=v;bb=p;}} else if(i==2){{rr=p;gg=v;bb=t;}}
  else if(i==3){{rr=p;gg=q;bb=v;}} else if(i==4){{rr=t;gg=p;bb=v;}} else {{rr=v;gg=p;bb=q;}}
  *r=(uint8_t)(rr*255.0f);*g=(uint8_t)(gg*255.0f);*b=(uint8_t)(bb*255.0f);
}}
static inline void add_rgb(uint8_t* r,uint8_t* g,uint8_t* b,float ar,float ag,float ab){{
  *r=(uint8_t)fminf(255.0f,(float)(*r)+ar); *g=(uint8_t)fminf(255.0f,(float)(*g)+ag); *b=(uint8_t)fminf(255.0f,(float)(*b)+ab);
}}
void setup(){{
  FastLED.addLeds<WS2812B, LED_PIN, GRB>(leds, NUM_LEDS); FastLED.setBrightness(255);
  pinMode(RESET_PIN,OUTPUT); pinMode(STROBE_PIN,OUTPUT); digitalWrite(RESET_PIN,LOW); digitalWrite(STROBE_PIN,HIGH);
}}
void loop(){{
  digitalWrite(RESET_PIN,HIGH); delayMicroseconds(5); digitalWrite(RESET_PIN,LOW);
  for(int i=0;i<7;i++){{ digitalWrite(STROBE_PIN,LOW); delayMicroseconds(30); float lv=read01(LEFT_PIN); float rv=read01(RIGHT_PIN); digitalWrite(STROBE_PIN,HIGH);
    B[i]=(1.0f-{alpha}f)*B[i]+{alpha}f*lv; B[i+7]=(1.0f-{alpha}f)*B[i+7]+{alpha}f*rv; }}
  float bass=0.5f*(B[0]+B[7]); float mid=(B[3]+B[4]+B[10]+B[11])*0.25f; float treb=0.5f*(B[6]+B[13]);
  float br=clamp01((float){br}f); float speed=(float){speed}f; float softness=clamp01((float){softness}f);
  float width=clamp01((float){width}f); float density=clamp01((float){density}f);
  float tt=millis()/1000.0f;
  float rot=tt*(0.25f+1.25f*speed)*(0.6f+1.8f*bass);
  float twist=2.0f+6.0f*density;
  float spine=0.5f+0.18f*sinf(tt*0.35f*speed+3.0f*bass);
  float rad=0.20f+0.25f*(0.25f+mid)+0.08f*sinf(tt*0.6f*speed);
  float sig=(0.010f+width*0.045f)*(0.8f+1.6f*softness);
  for(int p=0;p<NUM_LEDS;p++){{
    float x=(NUM_LEDS<=1)?0.0f:((float)p/(float)(NUM_LEDS-1));
    float ang=2.0f*3.1415926f*(x*twist+rot);
    float y1=spine+rad*sinf(ang), y2=spine-rad*sinf(ang);
    float d1=fabsf(x-y1); d1=fminf(d1,1.0f-d1); float d2=fabsf(x-y2); d2=fminf(d2,1.0f-d2);
    float a1=expf(-(d1*d1)/(2.0f*sig*sig)); float a2=expf(-(d2*d2)/(2.0f*sig*sig));
    float rung=0.5f+0.5f*sinf(2.0f*3.1415926f*(x*(3.0f+6.0f*density)-rot*0.6f));
    rung=powf(rung,2.5f)*(0.15f+0.85f*treb);
    float hue1=fmodf(0.62f+0.28f*x+0.06f*sinf(ang),1.0f);
    float hue2=fmodf(0.18f+0.28f*(1.0f-x)+0.06f*cosf(ang),1.0f);
    uint8_t r=0,g=0,b0=0,r1,g1,b1,r2,g2,b2; hsv_to_rgb(hue1,1.0f,1.0f,&r1,&g1,&b1); hsv_to_rgb(hue2,1.0f,1.0f,&r2,&g2,&b2);
    float v1=br*(0.06f+0.94f*a1*(0.35f+0.65f*(0.3f+bass)));
    float v2=br*(0.06f+0.94f*a2*(0.35f+0.65f*(0.3f+mid)));
    add_rgb(&r,&g,&b0,(float)r1*v1,(float)g1*v1,(float)b1*v1); add_rgb(&r,&g,&b0,(float)r2*v2,(float)g2*v2,(float)b2*v2);
    float rung_v=br*(0.18f*rung)*(0.4f+0.6f*(bass+mid)); if(rung_v>0.001f) add_rgb(&r,&g,&b0,255.0f*rung_v,210.0f*rung_v,255.0f*rung_v);
    leds[p]=CRGB(r,g,b0);
  }}
  FastLED.show(); delay(1);
}}
"""
def register_spectral_dna_helix_14():
    return register(BehaviorDef("spectral_dna_helix_14", title="Spectral DNA Helix (14-band)", uses=USES, preview_emit=_preview_emit, arduino_emit=_arduino_emit))
