from __future__ import annotations
SHIPPED = True

from typing import List, Tuple
import math
from behaviors.registry import BehaviorDef, register
RGB=Tuple[int,int,int]
def _clamp01(x: float)->float: return 0.0 if x<0.0 else (1.0 if x>1.0 else x)
def _hsv_to_rgb(h: float,s: float,v: float)->RGB:
    h=(h%1.0)*6.0; i=int(h)%6; f=h-float(i)
    p=v*(1.0-s); q=v*(1.0-f*s); t=v*(1.0-(1.0-f)*s)
    if i==0: r,g,b=v,t,p
    elif i==1: r,g,b=q,v,p
    elif i==2: r,g,b=p,v,t
    elif i==3: r,g,b=p,q,v
    elif i==4: r,g,b=t,p,v
    else: r,g,b=v,p,q
    return (int(r*255)&255,int(g*255)&255,int(b*255)&255)
USES=["brightness","speed","softness","density","width"]
def _preview_emit(*, num_leds:int, params:dict, t:float, state=None)->List[RGB]:
    n=max(1,int(num_leds))
    br=_clamp01(float(params.get("brightness",1.0)))
    speed=max(0.1,float(params.get("speed",1.0)))
    softness=_clamp01(float(params.get("softness",0.45)))
    density=_clamp01(float(params.get("density",0.60)))
    width=max(0.05,_clamp01(float(params.get("width",0.35))))
    audio=params.get("_audio_flat") or {}
    L=[float(audio.get(f"l{i}",0.0) or 0.0) for i in range(7)]
    R=[float(audio.get(f"r{i}",0.0) or 0.0) for i in range(7)]
    mono=[0.5*(L[i]+R[i]) for i in range(7)]
    bass=0.5*(mono[0]+mono[1]); mid=(mono[2]+mono[3]+mono[4])/3.0; treb=0.5*(mono[5]+mono[6])
    if state is None or not isinstance(state, dict): state={"bass":bass,"mid":mid,"treb":treb}
    a=0.05+0.45*softness
    state["bass"]=(1.0-a)*state["bass"]+a*bass
    state["mid"]=(1.0-a)*state["mid"]+a*mid
    state["treb"]=(1.0-a)*state["treb"]+a*treb
    bass,mid,treb=state["bass"],state["mid"],state["treb"]
    slices=2+int(round(6*_clamp01(mid*(0.6+0.6*density))))
    rot=t*(0.15+1.35*speed)*(0.6+2.2*bass)
    freq=2.0+9.0*(0.25+treb)*(0.4+0.6*density)
    sig=(0.010+width*0.050)*(0.7+1.6*softness)
    out=[]
    for i in range(n):
        x=i/max(1.0,(n-1))
        u=(x+rot)%1.0; u=u*slices; u=abs((u%2.0)-1.0)
        p=0.5+0.5*math.sin(2*math.pi*(u*freq+0.15*math.sin(rot*0.4)))
        p=p**(1.2+2.5*(0.2+treb))
        edge=min(1.0, math.exp(-((u-0.0)**2)/(2.0*sig*sig)) + math.exp(-((u-1.0)**2)/(2.0*sig*sig)))
        v=_clamp01(br*(0.06+0.74*p+0.45*edge*(0.3+0.7*treb)))
        hue=(0.58+0.30*u+0.12*math.sin(rot*0.2))%1.0
        out.append(_hsv_to_rgb(hue,1.0,v))
    return out
def _arduino_emit(*, layout:dict, params:dict)->str:
    n=int(layout["num_leds"]); pin=int(layout["led_pin"])
    br=max(0.0,min(1.0,float(params.get("brightness",1.0))))
    speed=max(0.1,float(params.get("speed",1.0)))
    softness=max(0.0,min(1.0,float(params.get("softness",0.45))))
    density=max(0.0,min(1.0,float(params.get("density",0.60))))
    width=max(0.05,min(1.0,float(params.get("width",0.35))))
    alpha=0.05+0.45*softness
    sig=(0.010+width*0.050)*(0.7+1.6*softness)
    return f"""// Generated by Modulo (Spectral Kaleidoscope Audio)
#include <FastLED.h>
#include <math.h>
#define NUM_LEDS {n}
#define LED_PIN {pin}
CRGB leds[NUM_LEDS];
const int RESET_PIN=5, STROBE_PIN=4, LEFT_PIN=A0, RIGHT_PIN=A1;
float bass=0.0f, mid=0.0f, treb=0.0f;
static inline float clamp01(float x){{return x<0?0:(x>1?1:x);}}
static inline float read01(int pin){{return clamp01((float)analogRead(pin)/1023.0f);}}
static inline void hsv_to_rgb(float h,float s,float v,uint8_t* r,uint8_t* g,uint8_t* b){{
  float hh=fmodf(h,1.0f)*6.0f; int i=(int)floorf(hh)%6; float f=hh-(float)i;
  float p=v*(1.0f-s), q=v*(1.0f-f*s), t=v*(1.0f-(1.0f-f)*s); float rr,gg,bb;
  if(i==0){{rr=v;gg=t;bb=p;}} else if(i==1){{rr=q;gg=v;bb=p;}} else if(i==2){{rr=p;gg=v;bb=t;}}
  else if(i==3){{rr=p;gg=q;bb=v;}} else if(i==4){{rr=t;gg=p;bb=v;}} else {{rr=v;gg=p;bb=q;}}
  *r=(uint8_t)(rr*255.0f);*g=(uint8_t)(gg*255.0f);*b=(uint8_t)(bb*255.0f);
}}
void setup(){{
  FastLED.addLeds<WS2812B, LED_PIN, GRB>(leds, NUM_LEDS); FastLED.setBrightness(255);
  pinMode(RESET_PIN,OUTPUT); pinMode(STROBE_PIN,OUTPUT); digitalWrite(RESET_PIN,LOW); digitalWrite(STROBE_PIN,HIGH);
}}
void loop(){{
  float mono[7];
  digitalWrite(RESET_PIN,HIGH); delayMicroseconds(5); digitalWrite(RESET_PIN,LOW);
  for(int i=0;i<7;i++){{ digitalWrite(STROBE_PIN,LOW); delayMicroseconds(30); float lv=read01(LEFT_PIN); float rv=read01(RIGHT_PIN); digitalWrite(STROBE_PIN,HIGH); mono[i]=0.5f*(lv+rv); }}
  float b=0.5f*(mono[0]+mono[1]); float m=(mono[2]+mono[3]+mono[4])/3.0f; float tr=0.5f*(mono[5]+mono[6]);
  bass=(1.0f-{alpha}f)*bass+{alpha}f*b; mid=(1.0f-{alpha}f)*mid+{alpha}f*m; treb=(1.0f-{alpha}f)*treb+{alpha}f*tr;
  float br=clamp01((float){br}f); float speed=(float){speed}f; float density=clamp01((float){density}f);
  int slices=2+(int)lroundf(6.0f*clamp01(mid*(0.6f+0.6f*density)));
  float rot=(millis()/1000.0f)*(0.15f+1.35f*speed)*(0.6f+2.2f*bass);
  float freq=2.0f+9.0f*(0.25f+treb)*(0.4f+0.6f*density);
  float sig=(float){sig}f;
  for(int i=0;i<NUM_LEDS;i++){{ float x=(NUM_LEDS<=1)?0.0f:((float)i/(float)(NUM_LEDS-1));
    float u=fmodf(x+rot,1.0f); u=u*(float)slices; u=fabsf(fmodf(u,2.0f)-1.0f);
    float p=0.5f+0.5f*sinf(2.0f*3.1415926f*(u*freq+0.15f*sinf(rot*0.4f)));
    p=powf(p,1.2f+2.5f*(0.2f+treb));
    float edge=fminf(1.0f, expf(-((u-0.0f)*(u-0.0f))/(2.0f*sig*sig)) + expf(-((u-1.0f)*(u-1.0f))/(2.0f*sig*sig)));
    float vv=clamp01(br*(0.06f+0.74f*p+0.45f*edge*(0.3f+0.7f*treb)));
    float hue=fmodf(0.58f+0.30f*u+0.12f*sinf(rot*0.2f),1.0f);
    uint8_t r,g,b0; hsv_to_rgb(hue,1.0f,vv,&r,&g,&b0); leds[i]=CRGB(r,g,b0);
  }}
  FastLED.show(); delay(1);
}}
"""
def register_spectral_kaleidoscope_audio():
    return register(BehaviorDef("spectral_kaleidoscope_audio", title="Spectral Kaleidoscope (Audio)", uses=USES, preview_emit=_preview_emit, arduino_emit=_arduino_emit))
