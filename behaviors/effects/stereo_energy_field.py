from __future__ import annotations
SHIPPED = True

from typing import List, Tuple
import math

from behaviors.registry import BehaviorDef, register

RGB = Tuple[int,int,int]

USES = ['brightness', 'density', 'softness', 'speed']

from runtime.shader_math_v1 import clamp01 as _clamp01, hsv_to_rgb as _hsv_to_rgb

def _preview_emit(*, num_leds: int, params: dict, t: float, state=None) -> List[RGB]:
    n=max(1,int(num_leds))
    br=_clamp01(float(params.get("brightness",1.0)))
    speed=max(0.1,float(params.get("speed",1.0)))
    softness=_clamp01(float(params.get("softness",0.45)))
    density=_clamp01(float(params.get("density",0.6)))  # turbulence amount

    audio = params.get("_audio_flat") or {}
    L = [float(audio.get(f"l{i}", 0.0) or 0.0) for i in range(7)]
    R = [float(audio.get(f"r{i}", 0.0) or 0.0) for i in range(7)]
    lE = sum(L)/7.0
    rE = sum(R)/7.0

    if state is None or not isinstance(state, dict):
        state={}
    a = 0.05 + 0.45*softness
    for k,val in [("lE",lE),("rE",rE)]:
        if k not in state: state[k]=val
        else: state[k]=(1.0-a)*state[k]+a*val
    lE,rE=state["lE"],state["rE"]
    center = 0.5*(lE+rE)

    out=[]
    for i in range(n):
        x = i / max(1.0,(n-1))
        # stereo split: left drives left hue, right drives right hue
        blend = x
        hueL = (0.80 + 0.12*math.sin(t*0.3*speed)) % 1.0
        hueR = (0.55 + 0.12*math.cos(t*0.28*speed)) % 1.0
        hue = (1.0-blend)*hueL + blend*hueR

        # energy field: bass influences slow waves, treb influences jitter
        bass = 0.5*(L[0]+R[0])
        treb = 0.5*(L[6]+R[6])
        wob = (0.12 + density*0.35) * (0.4 + 0.6*center)
        field = 0.5 + 0.5*math.sin(2*math.pi*(x*(1.2+2.2*density) + t*0.08*speed*(0.6+1.8*bass)))
        field += 0.25*math.sin(2*math.pi*(x*(3.0+5.0*density) - t*0.16*speed*(0.4+2.2*treb) + 0.2))
        field = 0.5 + 0.5*math.tanh((field-0.5)*2.2)

        # left/right gain
        gain = (1.0-blend)*lE + blend*rE
        v = br*(0.08 + 0.92*field*gain*(0.65+0.35*math.sin(t*0.9*speed + x*6.0*wob)))
        v = 0.0 if v < 0.0 else (1.0 if v > 1.0 else v)
        out.append(_hsv_to_rgb(hue, 1.0, v))
    return out

def _arduino_emit(*, layout: dict, params: dict) -> str:
    n=int(layout["num_leds"]); pin=int(layout["led_pin"])
    br=float(params.get("brightness",1.0))
    speed=max(0.1,float(params.get("speed",1.0)))
    softness=float(params.get("softness",0.45))
    density=float(params.get("density",0.6))
    if br<0: br=0.0
    if br>1: br=1.0
    if softness<0: softness=0.0
    if softness>1: softness=1.0
    if density<0: density=0.0
    if density>1: density=1.0
    alpha = 0.05 + 0.45*softness

    return f"""// Generated by Modulo (Stereo Energy Field)
#include <FastLED.h>
#include <math.h>

#define NUM_LEDS {n}
#define LED_PIN {pin}
CRGB leds[NUM_LEDS];

// MSGEQ7 pins (default)
const int RESET_PIN = 5;
const int STROBE_PIN = 4;
const int LEFT_PIN = A0;
const int RIGHT_PIN = A1;

float lE=0.0f, rE=0.0f;

static inline float clamp01(float x) {{
  if (x < 0.0f) return 0.0f;
  if (x > 1.0f) return 1.0f;
  return x;
}}

static inline void hsv_to_rgb(float h, float s, float v, uint8_t* r, uint8_t* g, uint8_t* b) {{
  float hh = fmodf(h, 1.0f) * 6.0f;
  int i = (int)floorf(hh) % 6;
  float f = hh - (float)i;
  float p = v * (1.0f - s);
  float q = v * (1.0f - f * s);
  float t = v * (1.0f - (1.0f - f) * s);
  float rr,gg,bb;
  if (i==0) {{ rr=v; gg=t; bb=p; }}
  else if (i==1) {{ rr=q; gg=v; bb=p; }}
  else if (i==2) {{ rr=p; gg=v; bb=t; }}
  else if (i==3) {{ rr=p; gg=q; bb=v; }}
  else if (i==4) {{ rr=t; gg=p; bb=v; }}
  else {{ rr=v; gg=p; bb=q; }}
  *r = (uint8_t)(rr*255.0f);
  *g = (uint8_t)(gg*255.0f);
  *b = (uint8_t)(bb*255.0f);
}}

static inline float read01(int pin) {{
  int v = analogRead(pin);
  return clamp01((float)v / 1023.0f);
}}

void setup() {{
  FastLED.addLeds<WS2812B, LED_PIN, GRB>(leds, NUM_LEDS);
  FastLED.setBrightness(255);
  pinMode(RESET_PIN, OUTPUT);
  pinMode(STROBE_PIN, OUTPUT);
  digitalWrite(RESET_PIN, LOW);
  digitalWrite(STROBE_PIN, HIGH);
}}

void loop() {{
  float L[7], R[7];
  digitalWrite(RESET_PIN, HIGH); delayMicroseconds(5); digitalWrite(RESET_PIN, LOW);
  for (int i=0;i<7;i++) {{
    digitalWrite(STROBE_PIN, LOW); delayMicroseconds(30);
    L[i] = read01(LEFT_PIN);
    R[i] = read01(RIGHT_PIN);
    digitalWrite(STROBE_PIN, HIGH);
  }}
  float le = 0.0f, re = 0.0f;
  for (int i=0;i<7;i++) {{ le += L[i]; re += R[i]; }}
  le /= 7.0f; re /= 7.0f;
  lE = (1.0f-{alpha}f)*lE + {alpha}f*le;
  rE = (1.0f-{alpha}f)*rE + {alpha}f*re;
  float center = 0.5f*(lE+rE);

  float bass = 0.5f*(L[0]+R[0]);
  float treb = 0.5f*(L[6]+R[6]);

  float t = (millis()/1000.0f);
  float speed = (float){speed}f;
  float dens = clamp01((float){density}f);
  float wob = (0.12f + dens*0.35f) * (0.4f + 0.6f*center);

  float hueL = fmodf(0.80f + 0.12f*sinf(t*0.3f*speed), 1.0f);
  float hueR = fmodf(0.55f + 0.12f*cosf(t*0.28f*speed), 1.0f);

  float br = clamp01((float){br}f);

  for (int i=0;i<NUM_LEDS;i++) {{
    float x = (NUM_LEDS<=1)?0.0f:((float)i/(float)(NUM_LEDS-1));
    float hue = (1.0f-x)*hueL + x*hueR;

    float field = 0.5f + 0.5f*sinf(2.0f*3.1415926f*(x*(1.2f+2.2f*dens) + t*0.08f*speed*(0.6f+1.8f*bass)));
    field += 0.25f*sinf(2.0f*3.1415926f*(x*(3.0f+5.0f*dens) - t*0.16f*speed*(0.4f+2.2f*treb) + 0.2f));
    field = 0.5f + 0.5f*tanhf((field-0.5f)*2.2f);

    float gain = (1.0f-x)*lE + x*rE;
    float vv = br*(0.08f + 0.92f*field*gain*(0.65f+0.35f*sinf(t*0.9f*speed + x*6.0f*wob)));
    vv = clamp01(vv);

    uint8_t r,g,bcol;
    hsv_to_rgb(hue, 1.0f, vv, &r,&g,&bcol);
    leds[i] = CRGB(r,g,bcol);
  }}

  FastLED.show();
  delay(1);
}}
"""

def register_stereo_energy_field():
    return register(BehaviorDef(
        "stereo_energy_field",
        title="Stereo Energy Field",
        uses=USES,
        preview_emit=_preview_emit,
        arduino_emit=_arduino_emit,
    ))
