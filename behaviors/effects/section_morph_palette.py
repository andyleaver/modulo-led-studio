from __future__ import annotations
SHIPPED = True

from typing import List, Tuple
import math
from behaviors.registry import BehaviorDef, register

RGB=Tuple[int,int,int]
USES=["brightness","speed","softness","density","width"]

def _clamp01(x: float) -> float:
    if x<0.0: return 0.0
    if x>1.0: return 1.0
    return x

def _hsv_to_rgb(h: float, s: float, v: float) -> RGB:
    h=(h%1.0)*6.0
    i=int(h)%6
    f=h-float(i)
    p=v*(1.0-s)
    q=v*(1.0-f*s)
    t=v*(1.0-(1.0-f)*s)
    if i==0: r,g,b=v,t,p
    elif i==1: r,g,b=q,v,p
    elif i==2: r,g,b=p,v,t
    elif i==3: r,g,b=p,q,v
    elif i==4: r,g,b=t,p,v
    else: r,g,b=v,p,q
    return (int(r*255)&255,int(g*255)&255,int(b*255)&255)

def _lerp(a: float,b: float,t: float)->float:
    return a + (b-a)*t

def _preview_emit(*, num_leds:int, params:dict, t:float, state=None)->List[RGB]:
    n=max(1,int(num_leds))
    br=_clamp01(float(params.get("brightness",1.0)))
    speed=max(0.1,float(params.get("speed",1.0)))
    softness=_clamp01(float(params.get("softness",0.45)))
    density=_clamp01(float(params.get("density",0.55))) # palette drift
    width=_clamp01(float(params.get("width",0.35)))     # detail frequency
    if width<0.05: width=0.05

    tempo=(params.get("_audio_tempo") or {})
    sec_change=float(tempo.get("sec_change",0.0) or 0.0)
    sec_id=int(float(tempo.get("sec_id",0.0) or 0.0))

    # track palette base and morph on section changes
    if state is None or not isinstance(state, dict):
        state={"h0":0.10, "h1":0.62, "mix":0.0, "sec":sec_id}
    if sec_id != state.get("sec", sec_id):
        state["sec"]=sec_id
        # rotate palette deterministically per section id
        state["h0"] = (0.10 + 0.13*(sec_id % 7)) % 1.0
        state["h1"] = (0.62 + 0.11*(sec_id % 9)) % 1.0
        state["mix"]=1.0
    # decay mix (morph)
    state["mix"]=max(0.0, state["mix"] - (0.35+1.2*(1.0-softness))*(1.0/60.0))

    # pattern controlled by audio energy
    ev=(params.get("_audio_events") or {})
    em=float(ev.get("energy_mono",0.0) or 0.0)
    bass=0.5*(float(ev.get("l0_level",0.0) or 0.0)+float(ev.get("r0_level",0.0) or 0.0))
    rate=(0.10 + 1.8*speed)*(0.4+1.6*bass)
    freq=(2.0 + 12.0*(0.25+em))*(0.4+0.6*(1.0-width))

    out=[]
    for i in range(n):
        x=i/max(1.0,(n-1))
        w=2*math.pi*(x*freq + t*rate)
        p=0.5+0.5*math.sin(w)
        p=p**(0.65+2.2*softness)
        # palette mix: on section change, invert and slowly return
        h0=state["h0"]; h1=state["h1"]
        inv = state["mix"]
        h = _lerp(h0, h1, p)
        h = (h + inv*0.33) % 1.0
        v = _clamp01(br*(0.08 + 0.92*p))
        out.append(_hsv_to_rgb(h, 1.0, v))
    return out

def _arduino_emit(*, layout:dict, params:dict)->str:
    # Arduino: simple palette drift keyed off beat/onset count (no heavy section clustering)
    n=int(layout["num_leds"]); pin=int(layout["led_pin"])
    br=float(params.get("brightness",1.0))
    speed=max(0.1,float(params.get("speed",1.0)))
    softness=float(params.get("softness",0.45))
    density=float(params.get("density",0.55))
    width=float(params.get("width",0.35))
    if br<0: br=0.0
    if br>1: br=1.0
    if softness<0: softness=0.0
    if softness>1: softness=1.0
    if density<0: density=0.0
    if density>1: density=1.0
    if width<0.05: width=0.05
    if width>1: width=1.0

    alpha=0.10 + 0.35*softness

    return f"""// Generated by Modulo (Section Morph Palette - Arduino simplified)
#include <FastLED.h>
#include <math.h>

#define NUM_LEDS {n}
#define LED_PIN {pin}
CRGB leds[NUM_LEDS];

// MSGEQ7 pins (default)
const int RESET_PIN = 5;
const int STROBE_PIN = 4;
const int LEFT_PIN = A0;
const int RIGHT_PIN = A1;

float mono=0.0f, mono_prev=0.0f, mono_peak=0.0f;
int mono_cd=0;
int beat_count=0;

static inline float clamp01(float x) {{
  if (x<0.0f) return 0.0f;
  if (x>1.0f) return 1.0f;
  return x;
}}
static inline float read01(int pin) {{
  int v=analogRead(pin);
  return clamp01((float)v/1023.0f);
}}
static inline void hsv_to_rgb(float h, float s, float v, uint8_t* r, uint8_t* g, uint8_t* b) {{
  float hh=fmodf(h,1.0f)*6.0f;
  int i=(int)floorf(hh)%6;
  float f=hh-(float)i;
  float p=v*(1.0f-s);
  float q=v*(1.0f-f*s);
  float t=v*(1.0f-(1.0f-f)*s);
  float rr,gg,bb;
  if (i==0) {{ rr=v; gg=t; bb=p; }}
  else if (i==1) {{ rr=q; gg=v; bb=p; }}
  else if (i==2) {{ rr=p; gg=v; bb=t; }}
  else if (i==3) {{ rr=p; gg=q; bb=v; }}
  else if (i==4) {{ rr=t; gg=p; bb=v; }}
  else {{ rr=v; gg=p; bb=q; }}
  *r=(uint8_t)(rr*255.0f); *g=(uint8_t)(gg*255.0f); *b=(uint8_t)(bb*255.0f);
}}

void setup() {{
  FastLED.addLeds<WS2812B, LED_PIN, GRB>(leds, NUM_LEDS);
  FastLED.setBrightness(255);
  pinMode(RESET_PIN, OUTPUT);
  pinMode(STROBE_PIN, OUTPUT);
  digitalWrite(RESET_PIN, LOW);
  digitalWrite(STROBE_PIN, HIGH);
}}

void loop() {{
  float le=0.0f,re=0.0f;
  digitalWrite(RESET_PIN, HIGH); delayMicroseconds(5); digitalWrite(RESET_PIN, LOW);
  for (int i=0;i<7;i++) {{
    digitalWrite(STROBE_PIN, LOW); delayMicroseconds(30);
    le += read01(LEFT_PIN);
    re += read01(RIGHT_PIN);
    digitalWrite(STROBE_PIN, HIGH);
  }}
  le/=7.0f; re/=7.0f;
  float em=0.5f*(le+re);

  mono_prev=mono;
  mono=(1.0f-{alpha}f)*mono + {alpha}f*em;
  float md=mono-mono_prev;
  mono_peak=fmaxf(mono_peak-0.020f, mono);
  float thr=0.05f + mono_peak*0.20f;

  bool beat=false;
  if (mono_cd>0) mono_cd--;
  else {{
    if (md > thr) {{ beat=true; mono_cd=4; }}
  }}
  if (beat) beat_count++;

  float br=clamp01((float){br}f);
  float softness=clamp01((float){softness}f);
  float width=clamp01((float){width}f);
  float speed=(float){speed}f;

  float bass=mono_peak;
  float rate=(0.10f + 1.8f*speed)*(0.4f+1.6f*bass);
  float freq=(2.0f + 12.0f*(0.25f+mono))*(0.4f+0.6f*(1.0f-width));

  float h0=fmodf(0.10f + 0.13f*(beat_count % 7), 1.0f);
  float h1=fmodf(0.62f + 0.11f*(beat_count % 9), 1.0f);
  float inv = (beat?1.0f:0.0f);

  float tt=millis()/1000.0f;

  for (int i=0;i<NUM_LEDS;i++) {{
    float x=(NUM_LEDS<=1)?0.0f:((float)i/(float)(NUM_LEDS-1));
    float w=2.0f*3.1415926f*(x*freq + tt*rate);
    float p=0.5f+0.5f*sinf(w);
    p=powf(p, 0.65f + 2.2f*softness);
    float h = h0 + (h1-h0)*p;
    h = fmodf(h + inv*0.33f, 1.0f);
    float v = clamp01(br*(0.08f + 0.92f*p));
    uint8_t r,g,b; hsv_to_rgb(h,1.0f,v,&r,&g,&b);
    leds[i]=CRGB(r,g,b);
  }}

  FastLED.show();
  delay(1);
}}
"""

def register_section_morph_palette():
    return register(BehaviorDef(
        "section_morph_palette",
        title="Section Morph Palette (Tempo/Sections)",
        uses=USES,
        preview_emit=_preview_emit,
        arduino_emit=_arduino_emit,
    ))
