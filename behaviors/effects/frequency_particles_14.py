from __future__ import annotations
SHIPPED = True

from typing import List, Tuple
import math

from behaviors.registry import BehaviorDef, register

RGB = Tuple[int,int,int]

def _clamp01(x: float) -> float:
    if x < 0.0: return 0.0
    if x > 1.0: return 1.0
    return x

def _hsv_to_rgb(h: float, s: float, v: float) -> RGB:
    h = (h % 1.0) * 6.0
    i = int(h) % 6
    f = h - float(i)
    p = v * (1.0 - s)
    q = v * (1.0 - f * s)
    t = v * (1.0 - (1.0 - f) * s)
    if i == 0: r,g,b = v,t,p
    elif i == 1: r,g,b = q,v,p
    elif i == 2: r,g,b = p,v,t
    elif i == 3: r,g,b = p,q,v
    elif i == 4: r,g,b = t,p,v
    else: r,g,b = v,p,q
    return (int(r*255)&255, int(g*255)&255, int(b*255)&255)

def _add(a: RGB, b: RGB) -> RGB:
    return (min(255,a[0]+b[0]), min(255,a[1]+b[1]), min(255,a[2]+b[2]))

def _hash_u32(x: int) -> int:
    x = (x ^ 0x9E3779B9) & 0xFFFFFFFF
    x = (x * 0x85EBCA6B) & 0xFFFFFFFF
    x = (x ^ (x >> 13)) & 0xFFFFFFFF
    x = (x * 0xC2B2AE35) & 0xFFFFFFFF
    x = (x ^ (x >> 16)) & 0xFFFFFFFF
    return x

def _u01(h: int) -> float:
    return float(h & 0xFFFFFF) / float(0x1000000)

USES = ["brightness","speed","density","softness","width"]

def _preview_emit(*, num_leds: int, params: dict, t: float, state=None) -> List[RGB]:
    n=max(1,int(num_leds))
    br=_clamp01(float(params.get("brightness",1.0)))
    speed=max(0.1,float(params.get("speed",1.0)))
    density=_clamp01(float(params.get("density",0.55)))   # spawn rate
    softness=_clamp01(float(params.get("softness",0.45))) # decay
    width=_clamp01(float(params.get("width",0.35)))       # particle size
    if width < 0.05: width = 0.05

    audio = params.get("_audio_flat") or {}
    bands = [float(audio.get(f"l{i}",0.0) or 0.0) for i in range(7)] + [float(audio.get(f"r{i}",0.0) or 0.0) for i in range(7)]

    if state is None or not isinstance(state, dict):
        state={"P": []}  # list of (x, v, hue, life)
    P = state["P"]

    # spawn based on band amplitudes
    base_rate = 8.0 + 40.0*density
    dt = 1.0/60.0
    # deterministic bucket spawning
    bucket = int(t * base_rate)
    # allow multiple spawns per frame
    for k in range(3):
        h = _hash_u32(bucket ^ (k*991))
        bi = int(_u01(h) * 14.0) % 14
        amp = max(0.0, min(1.0, bands[bi]))
        if amp < (0.15*(1.0-density)):
            continue
        if _u01(_hash_u32(h ^ 0x1234)) > amp:
            continue
        x = _u01(_hash_u32(h ^ 0xBEEF))
        # velocity: direction encodes L/R
        dir = -1.0 if bi < 7 else 1.0
        v = dir * (0.25 + 1.75*(bi/13.0)) * (0.4 + 1.6*speed) * (0.3 + 0.7*amp)
        hue = (0.62 + 0.33*(bi/13.0)) % 1.0
        life = 0.6 + 0.8*amp
        P.append([x, v, hue, life])

    # integrate and render
    decay = 0.35 + 1.35*(1.0-softness)
    size = 0.008 + width*0.045
    out=[(0,0,0) for _ in range(n)]
    newP=[]
    for x,v,hue,life in P:
        x = (x + v*dt) % 1.0
        life = life - decay*dt
        if life <= 0.0:
            continue
        newP.append([x,v,hue,life])

        pr,pg,pb = _hsv_to_rgb(hue, 1.0, 1.0)
        for i in range(n):
            xx = i / max(1.0,(n-1))
            d = abs(xx - x)
            d = min(d, 1.0-d)
            a = math.exp(-(d*d)/(2.0*size*size)) * life
            if a < 0.002: 
                continue
            out[i]=_add(out[i], (int(pr*br*a), int(pg*br*a), int(pb*br*a)))
    state["P"]=newP[-240:]  # cap
    return out

def _arduino_emit(*, layout: dict, params: dict) -> str:
    n=int(layout["num_leds"]); pin=int(layout["led_pin"])
    br=float(params.get("brightness",1.0))
    speed=max(0.1,float(params.get("speed",1.0)))
    density=float(params.get("density",0.55))
    softness=float(params.get("softness",0.45))
    width=float(params.get("width",0.35))
    if br<0: br=0.0
    if br>1: br=1.0
    if density<0: density=0.0
    if density>1: density=1.0
    if softness<0: softness=0.0
    if softness>1: softness=1.0
    if width<0.05: width=0.05
    if width>1: width=1.0

    base_rate = 8.0 + 40.0*density
    decay = 0.35 + 1.35*(1.0-softness)
    size = 0.008 + width*0.045

    # We'll use a fixed particle pool for Arduino
    MAXP = 180

    return f"""// Generated by Modulo (Frequency Particles 14)
#include <FastLED.h>
#include <math.h>

#define NUM_LEDS {n}
#define LED_PIN {pin}
CRGB leds[NUM_LEDS];

// MSGEQ7 pins (default)
const int RESET_PIN = 5;
const int STROBE_PIN = 4;
const int LEFT_PIN = A0;
const int RIGHT_PIN = A1;

static inline float clamp01(float x) {{
  if (x < 0.0f) return 0.0f;
  if (x > 1.0f) return 1.0f;
  return x;
}}

static inline uint32_t hash_u32(uint32_t x) {{
  x ^= 0x9E3779B9u;
  x *= 0x85EBCA6Bu;
  x ^= (x >> 13);
  x *= 0xC2B2AE35u;
  x ^= (x >> 16);
  return x;
}}

static inline float u01(uint32_t h) {{
  return (float)(h & 0xFFFFFFu) / 16777216.0f;
}}

static inline void hsv_to_rgb(float h, float s, float v, uint8_t* r, uint8_t* g, uint8_t* b) {{
  float hh = fmodf(h, 1.0f) * 6.0f;
  int i = (int)floorf(hh) % 6;
  float f = hh - (float)i;
  float p = v * (1.0f - s);
  float q = v * (1.0f - f * s);
  float t = v * (1.0f - (1.0f - f) * s);
  float rr,gg,bb;
  if (i==0) {{ rr=v; gg=t; bb=p; }}
  else if (i==1) {{ rr=q; gg=v; bb=p; }}
  else if (i==2) {{ rr=p; gg=v; bb=t; }}
  else if (i==3) {{ rr=p; gg=q; bb=v; }}
  else if (i==4) {{ rr=t; gg=p; bb=v; }}
  else {{ rr=v; gg=p; bb=q; }}
  *r = (uint8_t)(rr*255.0f);
  *g = (uint8_t)(gg*255.0f);
  *b = (uint8_t)(bb*255.0f);
}}

static inline float read01(int pin) {{
  int v = analogRead(pin);
  return clamp01((float)v / 1023.0f);
}}

static inline void add_rgb(uint8_t* r, uint8_t* g, uint8_t* b, float ar, float ag, float ab) {{
  float rr = fminf(255.0f, (float)(*r) + ar);
  float gg = fminf(255.0f, (float)(*g) + ag);
  float bb = fminf(255.0f, (float)(*b) + ab);
  *r = (uint8_t)rr; *g = (uint8_t)gg; *b = (uint8_t)bb;
}}

struct Particle {{
  float x;
  float v;
  float hue;
  float life;
  bool alive;
}};
Particle P[{MAXP}];

void setup() {{
  FastLED.addLeds<WS2812B, LED_PIN, GRB>(leds, NUM_LEDS);
  FastLED.setBrightness(255);
  pinMode(RESET_PIN, OUTPUT);
  pinMode(STROBE_PIN, OUTPUT);
  digitalWrite(RESET_PIN, LOW);
  digitalWrite(STROBE_PIN, HIGH);
  for (int i=0;i<{MAXP};i++) P[i].alive=false;
}}

int allocParticle() {{
  for (int i=0;i<{MAXP};i++) if (!P[i].alive) return i;
  return -1;
}}

void loop() {{
  // Read 14 bands quickly (no per-band smoothing; particles act as smoothing)
  float B[14];
  digitalWrite(RESET_PIN, HIGH); delayMicroseconds(5); digitalWrite(RESET_PIN, LOW);
  for (int i=0;i<7;i++) {{
    digitalWrite(STROBE_PIN, LOW); delayMicroseconds(30);
    float lv = read01(LEFT_PIN);
    float rv = read01(RIGHT_PIN);
    digitalWrite(STROBE_PIN, HIGH);
    B[i] = lv;
    B[i+7] = rv;
  }}

  float br = clamp01((float){br}f);
  float speed = (float){speed}f;
  float density = clamp01((float){density}f);
  float decay = (float){decay}f;
  float size = (float){size}f;

  // Spawn deterministically
  float base_rate = (float){base_rate}f;
  uint32_t bucket = (uint32_t)((millis()/1000.0f) * base_rate);

  for (int k=0; k<3; k++) {{
    uint32_t h = hash_u32(bucket ^ (uint32_t)(k*991));
    int bi = (int)(u01(h) * 14.0f) % 14;
    float amp = clamp01(B[bi]);
    if (amp < (0.15f*(1.0f-density))) continue;
    if (u01(hash_u32(h ^ 0x00001234u)) > amp) continue;

    int idx = allocParticle();
    if (idx < 0) break;

    float x = u01(hash_u32(h ^ 0x0000BEEFu));
    float dir = (bi < 7) ? -1.0f : 1.0f;
    float f = (float)bi / 13.0f;
    float v = dir * (0.25f + 1.75f*f) * (0.4f + 1.6f*speed) * (0.3f + 0.7f*amp);
    float hue = fmodf(0.62f + 0.33f*f, 1.0f);
    float life = 0.6f + 0.8f*amp;

    P[idx].x=x; P[idx].v=v; P[idx].hue=hue; P[idx].life=life; P[idx].alive=true;
  }}

  // Clear
  for (int i=0;i<NUM_LEDS;i++) leds[i]=CRGB(0,0,0);

  // Integrate and draw
  const float dt = 1.0f/60.0f;
  for (int pi=0; pi<{MAXP}; pi++) {{
    if (!P[pi].alive) continue;
    P[pi].x = fmodf(P[pi].x + P[pi].v*dt + 1.0f, 1.0f);
    P[pi].life -= decay*dt;
    if (P[pi].life <= 0.0f) {{ P[pi].alive=false; continue; }}

    uint8_t pr,pg,pb;
    hsv_to_rgb(P[pi].hue, 1.0f, 1.0f, &pr,&pg,&pb);

    for (int i=0;i<NUM_LEDS;i++) {{
      float xx = (NUM_LEDS<=1)?0.0f:((float)i/(float)(NUM_LEDS-1));
      float d = fabsf(xx - P[pi].x);
      d = fminf(d, 1.0f - d);
      float a = expf(-(d*d)/(2.0f*size*size)) * P[pi].life;
      if (a < 0.002f) continue;
      float kf = br*a;
      add_rgb(&leds[i].r, &leds[i].g, &leds[i].b, (float)pr*kf, (float)pg*kf, (float)pb*kf);
    }}
  }}

  FastLED.show();
  delay(1);
}}
"""

def register_frequency_particles_14():
    return register(BehaviorDef(
        "frequency_particles_14",
        title="Frequency Particles (14-band)",
        uses=USES,
        preview_emit=_preview_emit,
        arduino_emit=_arduino_emit,
    ))
