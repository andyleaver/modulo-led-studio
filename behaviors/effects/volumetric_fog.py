from __future__ import annotations
SHIPPED = True

from typing import List, Tuple
import math

from behaviors.registry import BehaviorDef, register

RGB = Tuple[int,int,int]

def _clamp01(x: float) -> float:
    if x < 0.0: return 0.0
    if x > 1.0: return 1.0
    return x

def _hash_u32(x: int) -> int:
    x = (x ^ 0x9E3779B9) & 0xFFFFFFFF
    x = (x * 0x85EBCA6B) & 0xFFFFFFFF
    x = (x ^ (x >> 13)) & 0xFFFFFFFF
    x = (x * 0xC2B2AE35) & 0xFFFFFFFF
    x = (x ^ (x >> 16)) & 0xFFFFFFFF
    return x

def _u01(h: int) -> float:
    return float(h & 0xFFFFFF) / float(0x1000000)

def _lerp(a: float, b: float, t: float) -> float:
    return a + (b-a)*t

def _noise1(x: float, seed: int) -> float:
    x0 = int(math.floor(x))
    x1 = x0 + 1
    t = x - float(x0)
    v0 = _u01(_hash_u32(x0 ^ seed))
    v1 = _u01(_hash_u32(x1 ^ seed))
    return _lerp(v0, v1, t)

def _fbm(x: float, seed: int) -> float:
    a = 0.0
    amp = 0.6
    freq = 1.0
    for o in range(4):
        a += amp * _noise1(x*freq, seed + o*101)
        freq *= 2.0
        amp *= 0.5
    return a

USES = ["color","brightness","speed","width","softness","density"]

def _preview_emit(*, num_leds: int, params: dict, t: float) -> List[RGB]:
    n = max(1, int(num_leds))
    col = params.get("color",(180,220,255))
    base = (int(col[0])&255, int(col[1])&255, int(col[2])&255)
    br = _clamp01(float(params.get("brightness", 1.0)))
    speed = max(0.1, float(params.get("speed", 1.0)))
    width = _clamp01(float(params.get("width", 0.45)))       # scale
    softness = _clamp01(float(params.get("softness", 0.65))) # softness
    density = _clamp01(float(params.get("density", 0.55)))   # contrast

    if width < 0.08: width = 0.08
    scale = (1.0/width) * 0.9
    fog = 0.10 + softness*0.55
    contrast = 0.6 + density*1.3

    out=[]
    for i in range(n):
        x = i / max(1.0,(n-1))
        d = abs(x-0.5)*2.0
        depth = 1.0 / (1.0 + d*2.8)
        v = _fbm(x*scale + t*speed*0.15, 7777)
        v = _clamp01((v - 0.35)*contrast + 0.35)
        # depth & fog lift blacks
        v = _clamp01(v*depth + fog*(1.0-depth))
        r = int(base[0]*br*v)
        g = int(base[1]*br*v)
        b = int(base[2]*br*v)
        # subtle bluish white highlights
        hi = _clamp01((v-0.6)*2.0)
        r = min(255, r + int(hi*40))
        g = min(255, g + int(hi*50))
        b = min(255, b + int(hi*70))
        out.append((r,g,b))
    return out

def _arduino_emit(*, layout: dict, params: dict) -> str:
    n = int(layout["num_leds"])
    pin = int(layout["led_pin"])
    col = params.get("color",(180,220,255))
    r0,g0,b0 = int(col[0])&255, int(col[1])&255, int(col[2])&255
    br = float(params.get("brightness", 1.0))
    speed = max(0.1, float(params.get("speed", 1.0)))
    width = float(params.get("width", 0.45))
    softness = float(params.get("softness", 0.65))
    density = float(params.get("density", 0.55))

    br = 0.0 if br < 0.0 else (1.0 if br > 1.0 else br)
    softness = 0.0 if softness < 0.0 else (1.0 if softness > 1.0 else softness)
    density = 0.0 if density < 0.0 else (1.0 if density > 1.0 else density)
    if width < 0.08: width = 0.08
    if width > 1.0: width = 1.0

    scale = (1.0/width) * 0.9
    fog = 0.10 + softness*0.55
    contrast = 0.6 + density*1.3
    period_ms = int(max(450.0, min(60000.0, 26000.0 / speed)))

    return f"""// Generated by Modulo (Effect: volumetric_fog)
#include <FastLED.h>
#include <math.h>

#define NUM_LEDS {n}
#define LED_PIN {pin}
CRGB leds[NUM_LEDS];

static inline float clamp01(float x) {{
  if (x < 0.0f) return 0.0f;
  if (x > 1.0f) return 1.0f;
  return x;
}}

static inline uint32_t hash_u32(uint32_t x) {{
  x ^= 0x9E3779B9u;
  x *= 0x85EBCA6Bu;
  x ^= (x >> 13);
  x *= 0xC2B2AE35u;
  x ^= (x >> 16);
  return x;
}}

static inline float u01(uint32_t h) {{
  return (float)(h & 0xFFFFFFu) / 16777216.0f;
}}

static inline float lerp(float a, float b, float t) {{
  return a + (b-a)*t;
}}

static inline float noise1(float x, uint32_t seed) {{
  int x0 = (int)floorf(x);
  int x1 = x0 + 1;
  float tt = x - (float)x0;
  float v0 = u01(hash_u32((uint32_t)x0 ^ seed));
  float v1 = u01(hash_u32((uint32_t)x1 ^ seed));
  return lerp(v0, v1, tt);
}}

static inline float fbm(float x, uint32_t seed) {{
  float a = 0.0f;
  float amp = 0.6f;
  float freq = 1.0f;
  for (int o=0; o<4; o++) {{
    a += amp * noise1(x*freq, seed + (uint32_t)o*101u);
    freq *= 2.0f;
    amp *= 0.5f;
  }}
  return a;
}}

void setup() {{
  FastLED.addLeds<WS2812B, LED_PIN, GRB>(leds, NUM_LEDS);
  FastLED.setBrightness(255);
}}

void loop() {{
  unsigned long now = millis();
  float phase = (float)(now % (unsigned long){period_ms}) / (float){period_ms};
  float t = phase;

  float br = clamp01((float){br}f);
  float scale = (float){scale}f;
  float fog = (float){fog}f;
  float contrast = (float){contrast}f;

  for (int i=0; i<NUM_LEDS; i++) {{
    float x = (NUM_LEDS<=1)?0.0f:((float)i/(float)(NUM_LEDS-1));
    float d = fabsf(x-0.5f)*2.0f;
    float depth = 1.0f / (1.0f + d*2.8f);

    float v = fbm(x*scale + t*(float){speed}f*0.15f, 7777u);
    v = clamp01((v - 0.35f)*contrast + 0.35f);
    v = clamp01(v*depth + fog*(1.0f-depth));

    int r = (int)((float){r0}f*br*v);
    int g = (int)((float){g0}f*br*v);
    int b = (int)((float){b0}f*br*v);

    float hi = clamp01((v-0.6f)*2.0f);
    r = (int)fminf(255.0f, (float)r + hi*40.0f);
    g = (int)fminf(255.0f, (float)g + hi*50.0f);
    b = (int)fminf(255.0f, (float)b + hi*70.0f);

    leds[i] = CRGB((uint8_t)r,(uint8_t)g,(uint8_t)b);
  }}

  FastLED.show();
  delay(1);
}}
"""

def register_volumetric_fog():
    return register(BehaviorDef(
        "volumetric_fog",
        title="Volumetric Fog / Cloud Drift",
        uses=USES,
        preview_emit=_preview_emit,
        arduino_emit=_arduino_emit,
    ))
