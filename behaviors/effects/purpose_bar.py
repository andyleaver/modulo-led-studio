from __future__ import annotations
SHIPPED = True

from typing import List, Tuple
import math
from behaviors.registry import BehaviorDef, register

RGB = Tuple[int,int,int]
USES = ["brightness","speed","width","softness"]

def _clamp01(x: float) -> float:
    if x < 0.0: return 0.0
    if x > 1.0: return 1.0
    return x

def _hsv_to_rgb(h: float, s: float, v: float) -> RGB:
    h=(h%1.0)*6.0
    i=int(h)%6
    f=h-float(i)
    p=v*(1.0-s)
    q=v*(1.0-f*s)
    t=v*(1.0-(1.0-f)*s)
    if i==0: r,g,b=v,t,p
    elif i==1: r,g,b=q,v,p
    elif i==2: r,g,b=p,v,t
    elif i==3: r,g,b=p,q,v
    elif i==4: r,g,b=t,p,v
    else: r,g,b=v,p,q
    return (int(r*255)&255,int(g*255)&255,int(b*255)&255)

def _preview_emit(*, num_leds: int, params: dict, t: float, state=None) -> List[RGB]:
    n=max(1,int(num_leds))
    br=_clamp01(float(params.get("brightness",1.0)))
    speed=max(0.1,float(params.get("speed",1.0)))
    width=_clamp01(float(params.get("width",0.25)))
    softness=_clamp01(float(params.get("softness",0.35)))

    # If purpose slots are unset (all zeros), provide demo defaults so the effect
    # is visible in Effect Audit and on first use.
    if (
        float(params.get("purpose_f0",0.0)) == 0.0 and
        float(params.get("purpose_f1",0.0)) == 0.0 and
        float(params.get("purpose_f2",0.0)) == 0.0 and
        float(params.get("purpose_f3",0.0)) == 0.0 and
        int(params.get("purpose_i0",0)) == 0 and
        int(params.get("purpose_i1",0)) == 0 and
        int(params.get("purpose_i2",0)) == 0 and
        int(params.get("purpose_i3",0)) == 0
    ):
        params["purpose_f0"] = 1.0   # health
        params["purpose_f1"] = 0.6   # ammo
        params["purpose_f2"] = 0.8   # shield
        params["purpose_f3"] = 0.0
        params["purpose_i0"] = 123

    # Purpose slots drive bar and accent pulses
    health=_clamp01(float(params.get("purpose_f0",0.0)))
    ammo=_clamp01(float(params.get("purpose_f1",0.0)))
    shield=_clamp01(float(params.get("purpose_f2",0.0)))
    score=int(params.get("purpose_i0",0) or 0)

    out=[(0,0,0) for _ in range(n)]
    bar_len=int(health*n)
    for i in range(bar_len):
        # green->red gradient based on health
        h=(0.33*(health))  # 0.0 red .. 0.33 green
        out[i]=_hsv_to_rgb(h,1.0, br*(0.2+0.8*health))

    # ammo pulses on right
    pulse=(0.5+0.5*math.sin(t*(2.0+6.0*speed)))**(0.6+1.2*softness)
    ammo_n=int(ammo*n*width)
    for j in range(ammo_n):
        i=n-1-j
        v=br*ammo*pulse
        out[i]=_hsv_to_rgb(0.58,1.0,v)  # blue

    # shield spark center glow
    center=n//2
    rad=max(1,int(1+width*0.2*n))
    for d in range(-rad, rad+1):
        i=center+d
        if 0<=i<n:
            w=1.0-abs(d)/max(1,rad)
            v=br*shield*w
            rr,gg,bb=out[i]
            sr,sg,sb=_hsv_to_rgb(0.78,1.0,v)  # purple
            out[i]=(min(255,rr+sr),min(255,gg+sg),min(255,bb+sb))

    # tiny score twinkle (deterministic)
    if score>0:
        idx = score % n
        out[idx]=(255,255,255)

    return out

def _arduino_emit(*, layout: dict, params: dict) -> str:
    # export parity: bar reads purpose_f0/f1/f2/i0 constants (or moduloted)
    n=int(layout["num_leds"]); pin=int(layout["led_pin"])
    br=float(params.get("brightness",1.0))
    speed=float(params.get("speed",1.0))
    width=float(params.get("width",0.25))
    softness=float(params.get("softness",0.35))
    return f"""// Generated by Modulo (Purpose Bar)
#include <FastLED.h>
#include <math.h>
#define NUM_LEDS {n}
#define LED_PIN {pin}
CRGB leds[NUM_LEDS];

static inline float clamp01(float x){{ if(x<0) return 0; if(x>1) return 1; return x; }}
static inline void hsv_to_rgb(float h, float s, float v, uint8_t* r, uint8_t* g, uint8_t* b){{
  float hh=fmodf(h,1.0f)*6.0f; int i=(int)floorf(hh)%6; float f=hh-(float)i;
  float p=v*(1.0f-s); float q=v*(1.0f-f*s); float t=v*(1.0f-(1.0f-f)*s);
  float rr,gg,bb;
  if(i==0){{rr=v;gg=t;bb=p;}} else if(i==1){{rr=q;gg=v;bb=p;}}
  else if(i==2){{rr=p;gg=v;bb=t;}} else if(i==3){{rr=p;gg=q;bb=v;}}
  else if(i==4){{rr=t;gg=p;bb=v;}} else {{rr=v;gg=p;bb=q;}}
  *r=(uint8_t)(rr*255.0f); *g=(uint8_t)(gg*255.0f); *b=(uint8_t)(bb*255.0f);
}}

void setup(){{
  FastLED.addLeds<WS2812B, LED_PIN, GRB>(leds, NUM_LEDS);
  FastLED.setBrightness(255);
}}

void loop(){{
  float br=clamp01({br}f);
  float speed={speed}f;
  float width=clamp01({width}f);
  float softness=clamp01({softness}f);

  // These are the purpose slots for this layer (may be moduloted by audio->purpose routes):
  float health=clamp01((float){params.get("purpose_f0",0.0)}f);
  float ammo=clamp01((float){params.get("purpose_f1",0.0)}f);
  float shield=clamp01((float){params.get("purpose_f2",0.0)}f);
  int score=(int){int(params.get("purpose_i0",0) or 0)};

  for(int i=0;i<NUM_LEDS;i++) leds[i]=CRGB(0,0,0);

  int bar_len=(int)(health*NUM_LEDS);
  for(int i=0;i<bar_len;i++){{
    float h=0.33f*health;
    uint8_t r,g,b; hsv_to_rgb(h,1.0f, br*(0.2f+0.8f*health), &r,&g,&b);
    leds[i]=CRGB(r,g,b);
  }}

  float tt=millis()/1000.0f;
  float pulse=powf(0.5f+0.5f*sinf(tt*(2.0f+6.0f*speed)), 0.6f+1.2f*softness);
  int ammo_n=(int)(ammo*NUM_LEDS*width);
  for(int j=0;j<ammo_n;j++){{
    int i=NUM_LEDS-1-j;
    uint8_t r,g,b; hsv_to_rgb(0.58f,1.0f, br*ammo*pulse, &r,&g,&b);
    leds[i]=CRGB(r,g,b);
  }}

  int center=NUM_LEDS/2;
  int rad=max(1,(int)(1+width*0.2f*NUM_LEDS));
  for(int d=-rad; d<=rad; d++){{
    int i=center+d;
    if(i<0||i>=NUM_LEDS) continue;
    float w=1.0f - fabsf((float)d)/(float)rad;
    uint8_t r,g,b; hsv_to_rgb(0.78f,1.0f, br*shield*w, &r,&g,&b);
    leds[i].r = qadd8(leds[i].r, r);
    leds[i].g = qadd8(leds[i].g, g);
    leds[i].b = qadd8(leds[i].b, b);
  }}

  if(score>0){{
    int idx = score % NUM_LEDS;
    leds[idx]=CRGB(255,255,255);
  }}

  FastLED.show();
  delay(1);
}}
"""

def register_purpose_bar():
    return register(BehaviorDef(
        "purpose_bar",
        title="Purpose Bar (Health/Ammo/Shield/Score)",
        uses=USES,
        preview_emit=_preview_emit,
        arduino_emit=_arduino_emit,
    ))
