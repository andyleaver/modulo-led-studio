from __future__ import annotations
SHIPPED = True

from typing import List, Tuple
import math

from behaviors.registry import BehaviorDef, register

RGB = Tuple[int,int,int]

def _clamp01(x: float) -> float:
    if x < 0.0: return 0.0
    if x > 1.0: return 1.0
    return x

def _apply_brightness(rgb: RGB, br: float) -> RGB:
    br = _clamp01(float(br))
    r,g,b = rgb
    return (int(r*br)&255, int(g*br)&255, int(b*br)&255)

USES = ["color","brightness","speed","softness","width"]

def _preview_emit(*, num_leds: int, params: dict, t: float) -> List[RGB]:
    n = max(1, int(num_leds))
    col = params.get("color", (255,0,0))
    br = float(params.get("brightness", 1.0))
    speed = float(params.get("speed", 1.0))
    softness = _clamp01(float(params.get("softness", 0.0)))
    # Width semantics: legacy 0..1 fraction (<=1.0) or pixels (>1.0)
    try:
        width_in = float(params.get("width", 12.0))
    except Exception:
        width_in = 12.0
    if width_in <= 1.0:
        thickness_px = int(round(max(0.01, width_in) * n))
    else:
        thickness_px = int(round(width_in))
    if thickness_px < 1:
        thickness_px = 1
    if thickness_px > n:
        thickness_px = n
    width = float(thickness_px) / float(max(1, n))  # thickness as fraction for internal math
    base = _apply_brightness((int(col[0])&255, int(col[1])&255, int(col[2])&255), br)

    head = (t * max(0.1, speed) * 0.25) % 1.0
    thickness = width
    out: List[RGB] = []
    for i in range(n):
        x = i / max(1.0, (n-1))
        d = (x - head) % 1.0
        if d > thickness:
            out.append((0,0,0))
            continue
        a = 1.0
        if softness > 0.0:
            edge = softness * thickness
            if edge > 1e-6 and d > (thickness-edge):
                a = max(0.0, 1.0 - (d - (thickness-edge)) / edge)
                a = a*a
        out.append((int(base[0]*a)&255, int(base[1]*a)&255, int(base[2]*a)&255))
    return out

def _arduino_emit(*, layout: dict, params: dict) -> str:
    n = int(layout["num_leds"])
    pin = int(layout["led_pin"])
    col = params.get("color",(255,0,0))
    br = float(params.get("brightness", 1.0))
    speed = float(params.get("speed", 1.0))
    softness = float(params.get("softness", 0.0))
    width_in = float(params.get("width", 12.0))
    if br < 0.0: br = 0.0
    if br > 1.0: br = 1.0
    if softness < 0.0: softness = 0.0
    if softness > 1.0: softness = 1.0
    # width: legacy 0..1 fraction (<=1.0) or pixels (>1.0)
    if width_in <= 1.0:
        thickness_px = int(round(max(0.01, width_in) * n))
    else:
        thickness_px = int(round(width_in))
    if thickness_px < 1: thickness_px = 1
    if thickness_px > n: thickness_px = n
    thickness = float(thickness_px) / float(max(1, n))

    r0 = int(int(col[0]) * br) & 255
    g0 = int(int(col[1]) * br) & 255
    b0 = int(int(col[2]) * br) & 255

    traverse_ms = int(max(800.0, min(30000.0, 9000.0 / max(0.2, speed))))
    # thickness already computed above

    return f"""// Generated by Modulo (Effect: color_wipe)
#include <FastLED.h>
#include <math.h>

#define NUM_LEDS {n}
#define LED_PIN {pin}
CRGB leds[NUM_LEDS];

static inline float clamp01(float x) {{
  if (x < 0.0f) return 0.0f;
  if (x > 1.0f) return 1.0f;
  return x;
}}

void setup() {{
  FastLED.addLeds<WS2812B, LED_PIN, GRB>(leds, NUM_LEDS);
  FastLED.setBrightness(255);
}}

void loop() {{
  unsigned long now = millis();
  float head = (float)(now % (unsigned long){traverse_ms}) / (float){traverse_ms};
  float softness = clamp01((float){softness}f);
  float thickness = (float){thickness}f;

  for (int i=0; i<NUM_LEDS; i++) {{
    float x = (NUM_LEDS <= 1) ? 0.0f : ((float)i / (float)(NUM_LEDS - 1));
    float d = x - head;
    while (d < 0.0f) d += 1.0f;
    if (d > thickness) {{
      leds[i] = CRGB(0,0,0);
      continue;
    }}
    float a = 1.0f;
    if (softness > 0.0f) {{
      float edge = softness * thickness;
      if (edge > 1e-6f && d > (thickness - edge)) {{
        float k = 1.0f - (d - (thickness - edge)) / edge;
        if (k < 0.0f) k = 0.0f;
        a = k*k;
      }}
    }}
    leds[i] = CRGB((uint8_t)({r0}f*a), (uint8_t)({g0}f*a), (uint8_t)({b0}f*a));
  }}

  FastLED.show();
  delay(1);
}}
"""

def register_color_wipe():
    return register(BehaviorDef(
        "color_wipe",
        title="Color Wipe",
        uses=USES,
        preview_emit=_preview_emit,
        arduino_emit=_arduino_emit,
    ))
