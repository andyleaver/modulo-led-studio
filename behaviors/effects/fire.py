from __future__ import annotations
SHIPPED = True

from typing import List, Tuple
import math

from behaviors.registry import BehaviorDef, register

RGB = Tuple[int,int,int]

def _clamp01(x: float) -> float:
    if x < 0.0: return 0.0
    if x > 1.0: return 1.0
    return x

def _hash_u32(x: int) -> int:
    x = (x ^ 0x9E3779B9) & 0xFFFFFFFF
    x = (x * 0x85EBCA6B) & 0xFFFFFFFF
    x = (x ^ (x >> 13)) & 0xFFFFFFFF
    x = (x * 0xC2B2AE35) & 0xFFFFFFFF
    x = (x ^ (x >> 16)) & 0xFFFFFFFF
    return x

def _u01(h: int) -> float:
    return float(h & 0xFFFFFF) / float(0x1000000)

def _smoothstep(a: float, b: float, x: float) -> float:
    if x <= a: return 0.0
    if x >= b: return 1.0
    t = (x - a) / (b - a)
    return t*t*(3.0 - 2.0*t)

def _lerp(a: float, b: float, t: float) -> float:
    return a + (b-a)*t

def _noise1(x: float, seed: int) -> float:
    # value noise with linear interpolation, deterministic
    x0 = int(math.floor(x))
    x1 = x0 + 1
    t = x - float(x0)
    h0 = _hash_u32(x0 ^ seed)
    h1 = _hash_u32(x1 ^ seed)
    v0 = _u01(h0)
    v1 = _u01(h1)
    return _lerp(v0, v1, t)

def _fire_palette(v: float) -> RGB:
    # v 0..1 => black->red->orange->yellow->white
    v = _clamp01(v)
    if v < 0.25:
        t = v / 0.25
        return (int(80*t), 0, 0)
    if v < 0.55:
        t = (v - 0.25) / 0.30
        return (255, int(120*t), 0)
    if v < 0.85:
        t = (v - 0.55) / 0.30
        return (255, 120 + int(120*t), int(60*t))
    t = (v - 0.85) / 0.15
    w = 240 + int(15*t)
    return (w, w, w)

def _apply_brightness(rgb: RGB, br: float) -> RGB:
    br = _clamp01(float(br))
    r,g,b = rgb
    return (int(r*br)&255, int(g*br)&255, int(b*br)&255)

USES = ["brightness","speed","density","softness","width"]

def _preview_emit(*, num_leds: int, params: dict, t: float) -> List[RGB]:
    n = max(1, int(num_leds))
    br = float(params.get("brightness", 1.0))
    speed = float(params.get("speed", 1.0))
    density = _clamp01(float(params.get("density", 0.7)))   # overall heat
    softness = _clamp01(float(params.get("softness", 0.6))) # smoothness
    width = _clamp01(float(params.get("width", 0.8)))       # flame height

    # scale controls spatial frequency; softness makes it smoother (lower freq)
    spatial = 0.20 + (1.0 - softness) * 0.95
    # time scroll
    scroll = t * max(0.1, speed) * (0.6 + (1.0 - softness) * 1.6)

    out: List[RGB] = []
    for i in range(n):
        y = i / max(1.0, (n-1))
        # inverted height: more intense near bottom
        base = (1.0 - y) ** 1.8
        # height mask: width controls how tall flames reach
        mask = 1.0 - _smoothstep(width, 1.0, y)
        # layered noise
        v = 0.0
        v += 0.60 * _noise1(i*spatial + scroll*1.0, 111)
        v += 0.30 * _noise1(i*spatial*2.0 + scroll*1.9, 222)
        v += 0.10 * _noise1(i*spatial*4.0 + scroll*3.7, 333)
        # shape into fire
        heat = density * base * mask * (0.45 + 0.85*v)
        rgb = _apply_brightness(_fire_palette(heat), br)
        out.append(rgb)
    return out

def _arduino_emit(*, layout: dict, params: dict) -> str:
    n = int(layout["num_leds"])
    pin = int(layout["led_pin"])
    br = float(params.get("brightness", 1.0))
    speed = float(params.get("speed", 1.0))
    density = float(params.get("density", 0.7))
    softness = float(params.get("softness", 0.6))
    width = float(params.get("width", 0.8))

    if br < 0.0: br = 0.0
    if br > 1.0: br = 1.0
    if density < 0.0: density = 0.0
    if density > 1.0: density = 1.0
    if softness < 0.0: softness = 0.0
    if softness > 1.0: softness = 1.0
    if width < 0.0: width = 0.0
    if width > 1.0: width = 1.0

    spatial = 0.20 + (1.0 - softness) * 0.95
    scroll_speed = max(0.1, speed) * (0.6 + (1.0 - softness) * 1.6)

    return f"""// Generated by Modulo (Effect: fire)
#include <FastLED.h>
#include <math.h>

#define NUM_LEDS {n}
#define LED_PIN {pin}
CRGB leds[NUM_LEDS];

static inline float clamp01(float x) {{
  if (x < 0.0f) return 0.0f;
  if (x > 1.0f) return 1.0f;
  return x;
}}

static inline uint32_t hash_u32(uint32_t x) {{
  x ^= 0x9E3779B9u;
  x *= 0x85EBCA6Bu;
  x ^= (x >> 13);
  x *= 0xC2B2AE35u;
  x ^= (x >> 16);
  return x;
}}

static inline float u01(uint32_t h) {{
  return (float)(h & 0xFFFFFFu) / 16777216.0f;
}}

static inline float lerp(float a, float b, float t) {{
  return a + (b-a)*t;
}}

static inline float smoothstep(float a, float b, float x) {{
  if (x <= a) return 0.0f;
  if (x >= b) return 1.0f;
  float t = (x - a) / (b - a);
  return t*t*(3.0f - 2.0f*t);
}}

static inline float noise1(float x, uint32_t seed) {{
  int x0 = (int)floorf(x);
  int x1 = x0 + 1;
  float t = x - (float)x0;
  float v0 = u01(hash_u32((uint32_t)x0 ^ seed));
  float v1 = u01(hash_u32((uint32_t)x1 ^ seed));
  return lerp(v0, v1, t);
}}

static inline CRGB fire_palette(float v) {{
  v = clamp01(v);
  if (v < 0.25f) {{
    float t = v / 0.25f;
    return CRGB((uint8_t)(80.0f*t), 0, 0);
  }}
  if (v < 0.55f) {{
    float t = (v - 0.25f) / 0.30f;
    return CRGB(255, (uint8_t)(120.0f*t), 0);
  }}
  if (v < 0.85f) {{
    float t = (v - 0.55f) / 0.30f;
    return CRGB(255, (uint8_t)(120.0f + 120.0f*t), (uint8_t)(60.0f*t));
  }}
  float t = (v - 0.85f) / 0.15f;
  float w = 240.0f + 15.0f*t;
  return CRGB((uint8_t)w, (uint8_t)w, (uint8_t)w);
}}

void setup() {{
  FastLED.addLeds<WS2812B, LED_PIN, GRB>(leds, NUM_LEDS);
  FastLED.setBrightness(255);
}}

void loop() {{
  unsigned long now = millis();
  float t = (float)now / 1000.0f;
  float br = clamp01((float){br}f);
  float density = clamp01((float){density}f);
  float softness = clamp01((float){softness}f);
  float width = clamp01((float){width}f);

  float spatial = (float){spatial}f;
  float scroll = t * (float){scroll_speed}f;

  for (int i=0; i<NUM_LEDS; i++) {{
    float y = (NUM_LEDS <= 1) ? 0.0f : ((float)i / (float)(NUM_LEDS - 1));
    float base = powf(1.0f - y, 1.8f);
    float mask = 1.0f - smoothstep(width, 1.0f, y);

    float v = 0.0f;
    v += 0.60f * noise1((float)i*spatial + scroll*1.0f, 111u);
    v += 0.30f * noise1((float)i*spatial*2.0f + scroll*1.9f, 222u);
    v += 0.10f * noise1((float)i*spatial*4.0f + scroll*3.7f, 333u);

    float heat = density * base * mask * (0.45f + 0.85f*v);
    CRGB c = fire_palette(heat);
    leds[i] = CRGB((uint8_t)((float)c.r * br), (uint8_t)((float)c.g * br), (uint8_t)((float)c.b * br));
  }}

  FastLED.show();
  delay(1);
}}
"""

def register_fire():
    return register(BehaviorDef(
        "fire",
        title="Fire / Flame",
        uses=USES,
        preview_emit=_preview_emit,
        arduino_emit=_arduino_emit,
    ))
