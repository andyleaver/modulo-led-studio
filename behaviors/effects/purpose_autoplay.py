from __future__ import annotations
SHIPPED = True

from typing import List, Tuple, Dict, Any
import math
from behaviors.registry import BehaviorDef, register

RGB = Tuple[int,int,int]
USES = ["brightness","speed","width","softness","density"]

def _clamp01(x: float) -> float:
    if x < 0.0: return 0.0
    if x > 1.0: return 1.0
    return x

def _hsv_to_rgb(h: float, s: float, v: float) -> RGB:
    h=(h%1.0)*6.0
    i=int(h)%6
    f=h-float(i)
    p=v*(1.0-s)
    q=v*(1.0-f*s)
    t=v*(1.0-(1.0-f)*s)
    if i==0: r,g,b=v,t,p
    elif i==1: r,g,b=q,v,p
    elif i==2: r,g,b=p,v,t
    elif i==3: r,g,b=p,q,v
    elif i==4: r,g,b=t,p,v
    else: r,g,b=v,p,q
    return (int(r*255)&255,int(g*255)&255,int(b*255)&255)

def _state_init(params: dict) -> Dict[str, Any]:
    # local state for gameplay demo
    return {
        "health": float(params.get("purpose_f0", 1.0) or 1.0),
        "ammo": float(params.get("purpose_f1", 1.0) or 1.0),
        "shield": float(params.get("purpose_f2", 0.0) or 0.0),
        "score": int(params.get("purpose_i0", 0) or 0),
        "cool": 0.0,
    }

def _state_tick(state: Dict[str,Any], dt: float, params: dict) -> Dict[str, Any]:
    # Deterministic "mini game": health drains; occasional "hit" spikes shield; score increments on "shots".
    speed=max(0.1,float(params.get("speed",1.0)))
    drain = 0.03*speed
    state["health"] = max(0.0, float(state.get("health",1.0)) - drain*dt)
    # auto-reload ammo and fire shots periodically
    state["cool"] = float(state.get("cool",0.0)) - dt
    if state["cool"] <= 0.0:
        state["cool"] = 0.35/max(0.2,speed)
        # fire: consume ammo, gain score
        a=float(state.get("ammo",1.0))
        a=max(0.0, a-0.08)
        state["ammo"]=a
        state["score"]=int(state.get("score",0))+1
        # small shield pulse on each shot
        state["shield"]=min(1.0, float(state.get("shield",0.0))+0.12)
    # reload ammo slowly
    state["ammo"]=min(1.0, float(state.get("ammo",0.0)) + 0.05*dt*speed)
    # shield decays
    state["shield"]=max(0.0, float(state.get("shield",0.0)) - 0.25*dt)

    # if health hits zero: "respawn"
    if state["health"] <= 0.0:
        state["health"]=1.0
        state["ammo"]=1.0
        state["shield"]=0.0
        state["score"]=0
        state["cool"]=0.0
    return state

def _apply_state_to_params(params: dict, state: Dict[str,Any]) -> dict:
    # Write into purpose slots for downstream effects / UI meters
    params["purpose_f0"]=float(state.get("health",0.0))
    params["purpose_f1"]=float(state.get("ammo",0.0))
    params["purpose_f2"]=float(state.get("shield",0.0))
    params["purpose_i0"]=int(state.get("score",0))
    return params

def _preview_emit(*, num_leds: int, params: dict, t: float, state=None) -> List[RGB]:
    # Visual uses the same rendering as purpose_bar but embedded here for showcase
    n=max(1,int(num_leds))
    br=_clamp01(float(params.get("brightness",1.0)))
    speed=max(0.1,float(params.get("speed",1.0)))
    width=_clamp01(float(params.get("width",0.22)))
    softness=_clamp01(float(params.get("softness",0.35)))

    health=_clamp01(float(params.get("purpose_f0",0.0)))
    ammo=_clamp01(float(params.get("purpose_f1",0.0)))
    shield=_clamp01(float(params.get("purpose_f2",0.0)))
    score=int(params.get("purpose_i0",0) or 0)

    out=[(0,0,0) for _ in range(n)]
    bar_len=int(health*n)
    for i in range(bar_len):
        h=(0.33*(health))
        out[i]=_hsv_to_rgb(h,1.0, br*(0.2+0.8*health))

    pulse=(0.5+0.5*math.sin(t*(2.0+6.0*speed)))**(0.6+1.2*softness)
    ammo_n=int(ammo*n*width)
    for j in range(ammo_n):
        i=n-1-j
        v=br*ammo*pulse
        out[i]=_hsv_to_rgb(0.58,1.0,v)

    center=n//2
    rad=max(1,int(1+width*0.2*n))
    for d in range(-rad, rad+1):
        i=center+d
        if 0<=i<n:
            w=1.0-abs(d)/max(1,rad)
            v=br*shield*w
            rr,gg,bb=out[i]
            sr,sg,sb=_hsv_to_rgb(0.78,1.0,v)
            out[i]=(min(255,rr+sr),min(255,gg+sg),min(255,bb+sb))

    if score>0:
        idx = score % n
        out[idx]=(255,255,255)

    return out

def _arduino_emit(*, layout: dict, params: dict) -> str:
    # Stateful export parity: embed same state update loop and render.
    n=int(layout["num_leds"]); pin=int(layout["led_pin"])
    br=float(params.get("brightness",1.0))
    speed=float(params.get("speed",1.0))
    width=float(params.get("width",0.22))
    softness=float(params.get("softness",0.35))
    return f"""// Generated by Modulo (Purpose Autoplay - Gameplay Demo)
#include <FastLED.h>
#include <math.h>
#define NUM_LEDS {n}
#define LED_PIN {pin}
CRGB leds[NUM_LEDS];

static inline float clamp01(float x){{ if(x<0) return 0; if(x>1) return 1; return x; }}
static inline void hsv_to_rgb(float h, float s, float v, uint8_t* r, uint8_t* g, uint8_t* b){{
  float hh=fmodf(h,1.0f)*6.0f; int i=(int)floorf(hh)%6; float f=hh-(float)i;
  float p=v*(1.0f-s); float q=v*(1.0f-f*s); float t=v*(1.0f-(1.0f-f)*s);
  float rr,gg,bb;
  if(i==0){{rr=v;gg=t;bb=p;}} else if(i==1){{rr=q;gg=v;bb=p;}}
  else if(i==2){{rr=p;gg=v;bb=t;}} else if(i==3){{rr=p;gg=q;bb=v;}}
  else if(i==4){{rr=t;gg=p;bb=v;}} else {{rr=v;gg=p;bb=q;}}
  *r=(uint8_t)(rr*255.0f); *g=(uint8_t)(gg*255.0f); *b=(uint8_t)(bb*255.0f);
}}

float health=1.0f, ammo=1.0f, shield=0.0f;
int score=0;
float cool=0.0f;

void setup(){{
  FastLED.addLeds<WS2812B, LED_PIN, GRB>(leds, NUM_LEDS);
  FastLED.setBrightness(255);
}}

void loop(){{
  float br=clamp01({br}f);
  float speed=max(0.1f, {speed}f);
  float width=clamp01({width}f);
  float softness=clamp01({softness}f);

  // fixed tick
  const float dt=0.0166667f;
  // state tick (matches preview)
  health = max(0.0f, health - (0.03f*speed)*dt);
  cool -= dt;
  if(cool <= 0.0f){{
    cool = 0.35f/max(0.2f,speed);
    ammo = max(0.0f, ammo - 0.08f);
    score += 1;
    shield = min(1.0f, shield + 0.12f);
  }}
  ammo = min(1.0f, ammo + (0.05f*dt*speed));
  shield = max(0.0f, shield - (0.25f*dt));
  if(health <= 0.0f){{
    health=1.0f; ammo=1.0f; shield=0.0f; score=0; cool=0.0f;
  }}

  for(int i=0;i<NUM_LEDS;i++) leds[i]=CRGB(0,0,0);

  int bar_len=(int)(clamp01(health)*NUM_LEDS);
  for(int i=0;i<bar_len;i++){{
    float h=0.33f*clamp01(health);
    uint8_t r,g,b; hsv_to_rgb(h,1.0f, br*(0.2f+0.8f*clamp01(health)), &r,&g,&b);
    leds[i]=CRGB(r,g,b);
  }}

  float tt=millis()/1000.0f;
  float pulse=powf(0.5f+0.5f*sinf(tt*(2.0f+6.0f*speed)), 0.6f+1.2f*softness);
  int ammo_n=(int)(clamp01(ammo)*NUM_LEDS*width);
  for(int j=0;j<ammo_n;j++){{
    int i=NUM_LEDS-1-j;
    uint8_t r,g,b; hsv_to_rgb(0.58f,1.0f, br*clamp01(ammo)*pulse, &r,&g,&b);
    leds[i]=CRGB(r,g,b);
  }}

  int center=NUM_LEDS/2;
  int rad=max(1,(int)(1+width*0.2f*NUM_LEDS));
  for(int d=-rad; d<=rad; d++){{
    int i=center+d;
    if(i<0||i>=NUM_LEDS) continue;
    float w=1.0f - fabsf((float)d)/(float)rad;
    uint8_t r,g,b; hsv_to_rgb(0.78f,1.0f, br*clamp01(shield)*w, &r,&g,&b);
    leds[i].r = qadd8(leds[i].r, r);
    leds[i].g = qadd8(leds[i].g, g);
    leds[i].b = qadd8(leds[i].b, b);
  }}

  if(score>0){{
    int idx = score % NUM_LEDS;
    leds[idx]=CRGB(255,255,255);
  }}

  FastLED.show();
  delay(16);
}}
"""

def register_purpose_autoplay():
    defn = BehaviorDef(
        "purpose_autoplay",
        title="Purpose Autoplay (Gameplay Demo)",
        uses=USES,
        preview_emit=_preview_emit,
        arduino_emit=_arduino_emit,
    )
    # attach state hooks without changing BehaviorDef constructor
    defn.state_init = _state_init
    defn.state_tick = _state_tick
    defn.state_apply_to_params = _apply_state_to_params
    return register(defn)
