from __future__ import annotations
SHIPPED = True

from typing import List, Tuple
import math
from behaviors.registry import BehaviorDef, register

RGB=Tuple[int,int,int]
USES=["brightness","softness","width","density"]  # speed not needed

def _clamp01(x: float) -> float:
    if x<0.0: return 0.0
    if x>1.0: return 1.0
    return x

def _hsv_to_rgb(h: float, s: float, v: float) -> RGB:
    h=(h%1.0)*6.0
    i=int(h)%6
    f=h-float(i)
    p=v*(1.0-s)
    q=v*(1.0-f*s)
    t=v*(1.0-(1.0-f)*s)
    if i==0: r,g,b=v,t,p
    elif i==1: r,g,b=q,v,p
    elif i==2: r,g,b=p,v,t
    elif i==3: r,g,b=p,q,v
    elif i==4: r,g,b=t,p,v
    else: r,g,b=v,p,q
    return (int(r*255)&255,int(g*255)&255,int(b*255)&255)

def _preview_emit(*, num_leds:int, params:dict, t:float, state=None)->List[RGB]:
    n=max(1,int(num_leds))
    br=_clamp01(float(params.get("brightness",1.0)))
    softness=_clamp01(float(params.get("softness",0.45)))
    width=_clamp01(float(params.get("width",0.35)))
    density=_clamp01(float(params.get("density",0.55))) # number of meters
    meters = 2 + int(6*density)
    if meters<2: meters=2

    # purpose channels expected on params already (ensure)
    f=[_clamp01(float(params.get(f"purpose_f{i}",0.0) or 0.0)) for i in range(4)]
    i01=[_clamp01(float(params.get(f"purpose_i{i}",0.0) or 0.0)) for i in range(4)]
    vals = (f + i01)[:meters]

    out=[]
    for idx in range(n):
        x=idx/max(1.0,(n-1))
        m = int(x*meters)
        m = min(meters-1, max(0,m))
        # local within meter cell
        x0 = (m/ meters)
        x1 = ((m+1)/meters)
        u = 0.0 if x1<=x0 else (x-x0)/(x1-x0)
        v = vals[m]
        # soft edge
        edge = u*(1.0-u)
        gate = edge ** (0.20 + 1.6*(1.0-width))
        # fill bar from bottom (u)
        fill = 1.0 if u <= v else 0.0
        aa = (0.25 + 0.75*gate) * fill
        aa = aa ** (0.75 + 2.0*softness)
        hue = (0.05 + 0.12*m + 0.05*math.sin(t*0.6)) % 1.0
        out.append(_hsv_to_rgb(hue, 1.0, _clamp01(br*aa)))
    return out

def _arduino_emit(*, layout:dict, params:dict)->str:
    # Arduino uses purpose channels as constants unless you add modulotors in app (which export already supports).
    n=int(layout["num_leds"]); pin=int(layout["led_pin"])
    br=float(params.get("brightness",1.0))
    softness=float(params.get("softness",0.45))
    width=float(params.get("width",0.35))
    density=float(params.get("density",0.55))
    if br<0: br=0.0
    if br>1: br=1.0
    if softness<0: softness=0.0
    if softness>1: softness=1.0
    if width<0.05: width=0.05
    if width>1: width=1.0
    if density<0: density=0.0
    if density>1: density=1.0
    meters = 2 + int(6*density)

    # pack purpose values
    vals=[float(params.get(f"purpose_f{i}",0.0) or 0.0) for i in range(4)] + [float(params.get(f"purpose_i{i}",0.0) or 0.0) for i in range(4)]
    vals=vals[:meters] + [0.0]*max(0, meters-len(vals))

    arr = ",".join(f"{max(0.0,min(1.0,v)):.4f}f" for v in vals)

    return f"""// Generated by Modulo (Purpose Meter)
#include <FastLED.h>
#include <math.h>

#define NUM_LEDS {n}
#define LED_PIN {pin}
CRGB leds[NUM_LEDS];

const int METERS = {meters};
float vals[METERS] = {{ {arr} }};

static inline float clamp01(float x) {{
  if (x<0.0f) return 0.0f;
  if (x>1.0f) return 1.0f;
  return x;
}}
static inline void hsv_to_rgb(float h, float s, float v, uint8_t* r, uint8_t* g, uint8_t* b) {{
  float hh=fmodf(h,1.0f)*6.0f;
  int i=(int)floorf(hh)%6;
  float f=hh-(float)i;
  float p=v*(1.0f-s);
  float q=v*(1.0f-f*s);
  float t=v*(1.0f-(1.0f-f)*s);
  float rr,gg,bb;
  if (i==0) {{ rr=v; gg=t; bb=p; }}
  else if (i==1) {{ rr=q; gg=v; bb=p; }}
  else if (i==2) {{ rr=p; gg=v; bb=t; }}
  else if (i==3) {{ rr=p; gg=q; bb=v; }}
  else if (i==4) {{ rr=t; gg=p; bb=v; }}
  else {{ rr=v; gg=p; bb=q; }}
  *r=(uint8_t)(rr*255.0f); *g=(uint8_t)(gg*255.0f); *b=(uint8_t)(bb*255.0f);
}}

void setup() {{
  FastLED.addLeds<WS2812B, LED_PIN, GRB>(leds, NUM_LEDS);
  FastLED.setBrightness(255);
}}

void loop() {{
  float br = clamp01((float){br}f);
  float softness = clamp01((float){softness}f);
  float width = clamp01((float){width}f);

  float tt = millis()/1000.0f;

  for (int idx=0; idx<NUM_LEDS; idx++) {{
    float x = (NUM_LEDS<=1)?0.0f:((float)idx/(float)(NUM_LEDS-1));
    int m = (int)floorf(x*(float)METERS);
    if (m<0) m=0; if (m>=METERS) m=METERS-1;

    float x0 = (float)m/(float)METERS;
    float x1 = (float)(m+1)/(float)METERS;
    float u = (x1<=x0)?0.0f:((x-x0)/(x1-x0));
    float v = clamp01(vals[m]);

    float edge=u*(1.0f-u);
    float gate=powf(edge, (0.20f + 1.6f*(1.0f-width)));
    float fill=(u<=v)?1.0f:0.0f;
    float aa=(0.25f + 0.75f*gate)*fill;
    aa=powf(aa, (0.75f + 2.0f*softness));

    float hue=fmodf(0.05f + 0.12f*(float)m + 0.05f*sinf(tt*0.6f), 1.0f);
    uint8_t r,g,b; hsv_to_rgb(hue,1.0f, clamp01(br*aa), &r,&g,&b);
    leds[idx]=CRGB(r,g,b);
  }}

  FastLED.show();
  delay(16);
}}
"""

def register_purpose_meter():
    return register(BehaviorDef(
        "purpose_meter",
        title="Purpose Meter (Purpose Channels)",
        uses=USES,
        preview_emit=_preview_emit,
        arduino_emit=_arduino_emit,
    ))
