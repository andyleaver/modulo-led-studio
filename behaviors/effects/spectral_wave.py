from __future__ import annotations
SHIPPED = True

from typing import List, Tuple
import math

from behaviors.registry import BehaviorDef, register

RGB = Tuple[int,int,int]

def _clamp01(x: float) -> float:
    if x < 0.0: return 0.0
    if x > 1.0: return 1.0
    return x

def _hsv_to_rgb(h: float, s: float, v: float) -> RGB:
    h = (h % 1.0) * 6.0
    i = int(h) % 6
    f = h - float(i)
    p = v * (1.0 - s)
    q = v * (1.0 - f * s)
    t = v * (1.0 - (1.0 - f) * s)
    if i == 0: r,g,b = v,t,p
    elif i == 1: r,g,b = q,v,p
    elif i == 2: r,g,b = p,v,t
    elif i == 3: r,g,b = p,q,v
    elif i == 4: r,g,b = t,p,v
    else: r,g,b = v,p,q
    return (int(r*255)&255, int(g*255)&255, int(b*255)&255)

USES = ["brightness","speed","softness"]

def _preview_emit(*, num_leds: int, params: dict, t: float, state=None) -> List[RGB]:
    n = max(1, int(num_leds))
    br = _clamp01(float(params.get("brightness", 1.0)))
    speed = max(0.1, float(params.get("speed", 1.0)))
    softness = _clamp01(float(params.get("softness", 0.35)))

    audio = params.get("_audio_flat") or {}
    L = [float(audio.get(f"l{i}", 0.0) or 0.0) for i in range(7)]
    R = [float(audio.get(f"r{i}", 0.0) or 0.0) for i in range(7)]
    mono = [(L[i]+R[i])*0.5 for i in range(7)]
    # emphasize bass for big waves, treble for detail
    bass = (mono[0] + mono[1]) * 0.5
    mid = (mono[2] + mono[3] + mono[4]) / 3.0
    treb = (mono[5] + mono[6]) * 0.5

    # smoothing
    if state is None or not isinstance(state, dict):
        state = {}
    a = 0.06 + 0.44*softness
    for k,val in [("bass",bass),("mid",mid),("treb",treb)]:
        if k not in state: state[k]=val
        else: state[k]=(1.0-a)*state[k]+a*val
    bass,mid,treb = state["bass"],state["mid"],state["treb"]

    out=[]
    for i in range(n):
        x = i / max(1.0,(n-1))
        # composite wave
        ph = t*0.6*speed
        w = 0.0
        w += (0.25 + 1.25*bass) * math.sin(2*math.pi*(x*1.0 + ph*0.45))
        w += (0.12 + 0.85*mid)  * math.sin(2*math.pi*(x*2.0 + ph*0.90 + 0.2))
        w += (0.06 + 0.65*treb) * math.sin(2*math.pi*(x*4.0 + ph*1.60 + 0.4))
        w = 0.5 + 0.5*math.tanh(w*0.55)
        hue = (0.58 + 0.25*w + 0.05*math.sin(2*math.pi*(x + ph*0.2))) % 1.0
        v = br*(0.10 + 0.90*w)
        out.append(_hsv_to_rgb(hue, 1.0, v))
    return out

def _arduino_emit(*, layout: dict, params: dict) -> str:
    n=int(layout["num_leds"]); pin=int(layout["led_pin"])
    br=float(params.get("brightness",1.0))
    speed=max(0.1,float(params.get("speed",1.0)))
    softness=float(params.get("softness",0.35))
    if br<0: br=0.0
    if br>1: br=1.0
    if softness<0: softness=0.0
    if softness>1: softness=1.0

    alpha = 0.06 + 0.44*softness

    return f"""// Generated by Modulo (Spectral Wave)
#include <FastLED.h>
#include <math.h>

#define NUM_LEDS {n}
#define LED_PIN {pin}
CRGB leds[NUM_LEDS];

// MSGEQ7 pins (default)
const int RESET_PIN = 5;
const int STROBE_PIN = 4;
const int LEFT_PIN = A0;
const int RIGHT_PIN = A1;

float bass=0.0f, mid=0.0f, treb=0.0f;

static inline float clamp01(float x) {{
  if (x < 0.0f) return 0.0f;
  if (x > 1.0f) return 1.0f;
  return x;
}}

static inline void hsv_to_rgb(float h, float s, float v, uint8_t* r, uint8_t* g, uint8_t* b) {{
  float hh = fmodf(h, 1.0f) * 6.0f;
  int i = (int)floorf(hh) % 6;
  float f = hh - (float)i;
  float p = v * (1.0f - s);
  float q = v * (1.0f - f * s);
  float t = v * (1.0f - (1.0f - f) * s);
  float rr,gg,bb;
  if (i==0) {{ rr=v; gg=t; bb=p; }}
  else if (i==1) {{ rr=q; gg=v; bb=p; }}
  else if (i==2) {{ rr=p; gg=v; bb=t; }}
  else if (i==3) {{ rr=p; gg=q; bb=v; }}
  else if (i==4) {{ rr=t; gg=p; bb=v; }}
  else {{ rr=v; gg=p; bb=q; }}
  *r = (uint8_t)(rr*255.0f);
  *g = (uint8_t)(gg*255.0f);
  *b = (uint8_t)(bb*255.0f);
}}

static inline float read01(int pin) {{
  int v = analogRead(pin);
  return clamp01((float)v / 1023.0f);
}}

void setup() {{
  FastLED.addLeds<WS2812B, LED_PIN, GRB>(leds, NUM_LEDS);
  FastLED.setBrightness(255);
  pinMode(RESET_PIN, OUTPUT);
  pinMode(STROBE_PIN, OUTPUT);
  digitalWrite(RESET_PIN, LOW);
  digitalWrite(STROBE_PIN, HIGH);
}}

void loop() {{
  // read bands
  float mono[7];
  digitalWrite(RESET_PIN, HIGH); delayMicroseconds(5); digitalWrite(RESET_PIN, LOW);
  for (int i=0;i<7;i++) {{
    digitalWrite(STROBE_PIN, LOW); delayMicroseconds(30);
    float lv = read01(LEFT_PIN);
    float rv = read01(RIGHT_PIN);
    digitalWrite(STROBE_PIN, HIGH);
    mono[i] = 0.5f*(lv+rv);
  }}

  float b = 0.5f*(mono[0]+mono[1]);
  float m = (mono[2]+mono[3]+mono[4]) / 3.0f;
  float t = 0.5f*(mono[5]+mono[6]);

  bass = (1.0f-{alpha}f)*bass + {alpha}f*b;
  mid  = (1.0f-{alpha}f)*mid  + {alpha}f*m;
  treb = (1.0f-{alpha}f)*treb + {alpha}f*t;

  float ph = (millis() / 1000.0f) * 0.6f * (float){speed}f;
  float br = clamp01((float){br}f);

  for (int i=0;i<NUM_LEDS;i++) {{
    float x = (NUM_LEDS<=1)?0.0f:((float)i/(float)(NUM_LEDS-1));
    float w = 0.0f;
    w += (0.25f + 1.25f*bass) * sinf(2.0f*3.1415926f*(x*1.0f + ph*0.45f));
    w += (0.12f + 0.85f*mid)  * sinf(2.0f*3.1415926f*(x*2.0f + ph*0.90f + 0.2f));
    w += (0.06f + 0.65f*treb) * sinf(2.0f*3.1415926f*(x*4.0f + ph*1.60f + 0.4f));
    w = 0.5f + 0.5f*tanhf(w*0.55f);
    float hue = fmodf(0.58f + 0.25f*w + 0.05f*sinf(2.0f*3.1415926f*(x + ph*0.2f)), 1.0f);
    float vv = br*(0.10f + 0.90f*w);
    uint8_t r,g,bcol;
    hsv_to_rgb(hue, 1.0f, vv, &r,&g,&bcol);
    leds[i] = CRGB(r,g,bcol);
  }}

  FastLED.show();
  delay(1);
}}
"""

def register_spectral_wave():
    return register(BehaviorDef(
        "spectral_wave",
        title="Spectral Wave",
        uses=USES,
        preview_emit=_preview_emit,
        arduino_emit=_arduino_emit,
    ))
