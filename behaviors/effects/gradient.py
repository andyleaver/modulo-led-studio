from __future__ import annotations
SHIPPED = True

from typing import List, Tuple
import math

from behaviors.registry import BehaviorDef, register

RGB = Tuple[int,int,int]

def _clamp01(x: float) -> float:
    if x < 0.0: return 0.0
    if x > 1.0: return 1.0
    return x

def _lerp(a: float, b: float, t: float) -> float:
    return a + (b-a)*t

def _lerp_rgb(a: RGB, b: RGB, t: float) -> RGB:
    return (int(_lerp(a[0], b[0], t)) & 255,
            int(_lerp(a[1], b[1], t)) & 255,
            int(_lerp(a[2], b[2], t)) & 255)

def _apply_brightness(rgb: RGB, br: float) -> RGB:
    br = _clamp01(float(br))
    r,g,b = rgb
    return (int(r*br)&255, int(g*br)&255, int(b*br)&255)

USES = ["color","brightness","speed","width","softness"]

def _preview_emit(*, num_leds: int, params: dict, t: float) -> List[RGB]:
    # uses 'color' as primary and 'softness' maps to secondary color mix bias (simple)
    n = max(1, int(num_leds))
    c1 = params.get("color",(255,0,200))
    # derive secondary by rotating channels unless user later adds explicit color2; this keeps catalog stable
    c2 = (int(c1[2])&255, int(c1[0])&255, int(c1[1])&255)

    br = float(params.get("brightness", 1.0))
    speed = float(params.get("speed", 1.0))
    width = _clamp01(float(params.get("width", 1.0)))  # gradient scale; smaller repeats
    softness = _clamp01(float(params.get("softness", 0.5))) # blend curve
    if width < 0.1: width = 0.1

    phase = (t * max(0.1, speed) * 0.12) % 1.0
    exp = 0.7 + (1.0-softness)*1.8

    out: List[RGB] = []
    for i in range(n):
        x = i / max(1.0, (n-1))
        u = (x / width + phase) % 1.0
        # smooth blend
        v = 0.5 - 0.5*math.cos(2.0*math.pi*u)
        v = pow(v, exp)
        out.append(_apply_brightness(_lerp_rgb((int(c1[0])&255,int(c1[1])&255,int(c1[2])&255), c2, v), br))
    return out

def _arduino_emit(*, layout: dict, params: dict) -> str:
    n = int(layout["num_leds"])
    pin = int(layout["led_pin"])
    c1 = params.get("color",(255,0,200))
    c2 = (int(c1[2])&255, int(c1[0])&255, int(c1[1])&255)

    br = float(params.get("brightness", 1.0))
    speed = float(params.get("speed", 1.0))
    width = float(params.get("width", 1.0))
    softness = float(params.get("softness", 0.5))

    if br < 0.0: br = 0.0
    if br > 1.0: br = 1.0
    if width < 0.1: width = 0.1
    if width > 1.0: width = 1.0
    if softness < 0.0: softness = 0.0
    if softness > 1.0: softness = 1.0

    r1,g1,b1 = int(c1[0])&255, int(c1[1])&255, int(c1[2])&255
    r2,g2,b2 = int(c2[0])&255, int(c2[1])&255, int(c2[2])&255

    period_ms = int(max(1200.0, min(60000.0, 22000.0 / max(0.2, speed))))
    exp = 0.7 + (1.0-softness)*1.8

    return f"""// Generated by Modulo (Effect: gradient)
#include <FastLED.h>
#include <math.h>

#define NUM_LEDS {n}
#define LED_PIN {pin}
CRGB leds[NUM_LEDS];

static inline float clamp01(float x) {{
  if (x < 0.0f) return 0.0f;
  if (x > 1.0f) return 1.0f;
  return x;
}}

static inline float lerp(float a, float b, float t) {{
  return a + (b-a)*t;
}}

void setup() {{
  FastLED.addLeds<WS2812B, LED_PIN, GRB>(leds, NUM_LEDS);
  FastLED.setBrightness(255);
}}

void loop() {{
  unsigned long now = millis();
  float phase = (float)(now % (unsigned long){period_ms}) / (float){period_ms}; // 0..1
  float br = clamp01((float){br}f);
  float width = (float){width}f;
  float exp = (float){exp}f;

  for (int i=0; i<NUM_LEDS; i++) {{
    float x = (NUM_LEDS <= 1) ? 0.0f : ((float)i / (float)(NUM_LEDS - 1));
    float u = fmodf((x / width) + phase, 1.0f);
    float v = 0.5f - 0.5f * cosf(2.0f * 3.1415926f * u);
    v = powf(v, exp);

    float rr = lerp((float){r1}f, (float){r2}f, v) * br;
    float gg = lerp((float){g1}f, (float){g2}f, v) * br;
    float bb = lerp((float){b1}f, (float){b2}f, v) * br;
    leds[i] = CRGB((uint8_t)rr, (uint8_t)gg, (uint8_t)bb);
  }}

  FastLED.show();
  delay(1);
}}
"""

def register_gradient():
    return register(BehaviorDef(
        "gradient",
        title="Gradient / Color Cycle",
        uses=USES,
        preview_emit=_preview_emit,
        arduino_emit=_arduino_emit,
    ))
