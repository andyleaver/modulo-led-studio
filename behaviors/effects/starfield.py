from __future__ import annotations
SHIPPED = True

from typing import List, Tuple
import math

from behaviors.registry import BehaviorDef, register

RGB = Tuple[int,int,int]

def _clamp01(x: float) -> float:
    if x < 0.0: return 0.0
    if x > 1.0: return 1.0
    return x

def _hash_u32(x: int) -> int:
    x = (x ^ 0x9E3779B9) & 0xFFFFFFFF
    x = (x * 0x85EBCA6B) & 0xFFFFFFFF
    x = (x ^ (x >> 13)) & 0xFFFFFFFF
    x = (x * 0xC2B2AE35) & 0xFFFFFFFF
    x = (x ^ (x >> 16)) & 0xFFFFFFFF
    return x

def _u01(h: int) -> float:
    return float(h & 0xFFFFFF) / float(0x1000000)

def _apply_brightness(rgb: RGB, br: float) -> RGB:
    br = _clamp01(float(br))
    r,g,b = rgb
    return (int(r*br)&255, int(g*br)&255, int(b*br)&255)

USES = ["color","brightness","speed","density","softness"]

def _preview_emit(*, num_leds: int, params: dict, t: float) -> List[RGB]:
    n = max(1, int(num_leds))
    col = params.get("color",(255,255,255))
    br = float(params.get("brightness", 1.0))
    speed = float(params.get("speed", 1.0))
    density = _clamp01(float(params.get("density", 0.35)))   # star count
    softness = _clamp01(float(params.get("softness", 0.35))) # streak size

    base = (int(col[0])&255, int(col[1])&255, int(col[2])&255)

    # stars
    star_n = max(6, int(round(density * 60)))
    # motion along "depth" repeats every period
    period = 1.8 / max(0.2, speed)  # seconds
    tau = (t / period) % 1.0  # 0..1
    # soft streak sigma
    sigma = 0.6 + softness * 2.5

    out = [(0,0,0) for _ in range(n)]
    for s in range(star_n):
        h = _hash_u32(s * 9127)
        pos0 = _u01(h)  # base position
        depth0 = _u01(_hash_u32(h ^ 0x12345))  # 0..1 (near=1 bright)
        # star moves outward: position drifts from center based on depth
        # map to strip: project from center
        dir_ = -1.0 if (_hash_u32(h ^ 0xCAFE) & 1) else 1.0
        # depth evolves with tau
        depth = (depth0 + tau) % 1.0
        z = 1.0 - depth  # near when depth small
        # project: closer => further from center
        spread = (1.0 / max(0.2, z)) - 1.0
        x = 0.5 + dir_ * (pos0 - 0.5) * min(1.0, 0.25 + 0.18*spread)
        # clamp
        if x < 0.0 or x > 1.0:
            continue
        idx = x * (n-1 if n>1 else 1)
        # brightness: near brighter
        a0 = (1.0 - z)
        a0 = a0*a0
        a0 *= (0.35 + 0.65*(1.0-depth0))
        # streak: draw gaussian around idx
        for i in range(n):
            d = abs(i - idx)
            if d > 6.0*sigma:
                continue
            a = math.exp(-(d*d)/(2.0*sigma*sigma)) * a0
            rr = min(255, out[i][0] + int(base[0]*br*a))
            gg = min(255, out[i][1] + int(base[1]*br*a))
            bb = min(255, out[i][2] + int(base[2]*br*a))
            out[i] = (rr,gg,bb)
    return out

def _arduino_emit(*, layout: dict, params: dict) -> str:
    n = int(layout["num_leds"])
    pin = int(layout["led_pin"])
    col = params.get("color",(255,255,255))
    br = float(params.get("brightness", 1.0))
    speed = float(params.get("speed", 1.0))
    density = float(params.get("density", 0.35))
    softness = float(params.get("softness", 0.35))

    if br < 0.0: br = 0.0
    if br > 1.0: br = 1.0
    if density < 0.0: density = 0.0
    if density > 1.0: density = 1.0
    if softness < 0.0: softness = 0.0
    if softness > 1.0: softness = 1.0

    r0,g0,b0 = int(col[0])&255, int(col[1])&255, int(col[2])&255
    star_n = max(6, int(round(density * 60.0)))
    sigma = 0.6 + softness * 2.5
    # period_ms
    period_ms = int(max(400.0, min(60000.0, (1.8 / max(0.2, speed)) * 1000.0)))

    return f"""// Generated by Modulo (Effect: starfield)
#include <FastLED.h>
#include <math.h>

#define NUM_LEDS {n}
#define LED_PIN {pin}
CRGB leds[NUM_LEDS];

static inline float clamp01(float x) {{
  if (x < 0.0f) return 0.0f;
  if (x > 1.0f) return 1.0f;
  return x;
}}

static inline uint32_t hash_u32(uint32_t x) {{
  x ^= 0x9E3779B9u;
  x *= 0x85EBCA6Bu;
  x ^= (x >> 13);
  x *= 0xC2B2AE35u;
  x ^= (x >> 16);
  return x;
}}

static inline float u01(uint32_t h) {{
  return (float)(h & 0xFFFFFFu) / 16777216.0f;
}}

static inline float gauss(float d, float sigma) {{
  return expf(-(d*d) / (2.0f*sigma*sigma));
}}

void setup() {{
  FastLED.addLeds<WS2812B, LED_PIN, GRB>(leds, NUM_LEDS);
  FastLED.setBrightness(255);
}}

void loop() {{
  unsigned long now = millis();
  float tau = (float)(now % (unsigned long){period_ms}) / (float){period_ms}; // 0..1
  float br = clamp01((float){br}f);
  float sigma = (float){sigma}f;

  for (int i=0; i<NUM_LEDS; i++) leds[i] = CRGB(0,0,0);

  for (int s=0; s<{star_n}; s++) {{
    uint32_t h = hash_u32((uint32_t)s * 9127u);
    float pos0 = u01(h);
    float depth0 = u01(hash_u32(h ^ 0x00012345u));
    float depth = fmodf(depth0 + tau, 1.0f);
    float z = 1.0f - depth; // near when small
    float spread = (1.0f / fmaxf(0.2f, z)) - 1.0f;
    float dir = (hash_u32(h ^ 0x0000CAFEu) & 1u) ? -1.0f : 1.0f;
    float x = 0.5f + dir * (pos0 - 0.5f) * fminf(1.0f, 0.25f + 0.18f*spread);
    if (x < 0.0f || x > 1.0f) continue;
    float idx = x * (float)(NUM_LEDS - 1);

    float a0 = (1.0f - z);
    a0 = a0*a0;
    a0 *= (0.35f + 0.65f*(1.0f - depth0));

    for (int i=0; i<NUM_LEDS; i++) {{
      float d = fabsf((float)i - idx);
      if (d > 6.0f*sigma) continue;
      float a = gauss(d, sigma) * a0 * br;
      uint8_t r = (uint8_t)fminf(255.0f, (float)leds[i].r + (float){r0}f * a);
      uint8_t g = (uint8_t)fminf(255.0f, (float)leds[i].g + (float){g0}f * a);
      uint8_t b = (uint8_t)fminf(255.0f, (float)leds[i].b + (float){b0}f * a);
      leds[i] = CRGB(r,g,b);
    }}
  }}

  FastLED.show();
  delay(1);
}}
"""

def register_starfield():
    return register(BehaviorDef(
        "starfield",
        title="Starfield (Pseudo-3D)",
        uses=USES,
        preview_emit=_preview_emit,
        arduino_emit=_arduino_emit,
    ))
