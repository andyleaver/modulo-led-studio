from __future__ import annotations
SHIPPED = True

from typing import List, Tuple
import math
from behaviors.registry import BehaviorDef, register

RGB = Tuple[int,int,int]
USES = ["brightness","speed","softness","density","width"]

def _clamp01(x: float) -> float:
    if x < 0.0: return 0.0
    if x > 1.0: return 1.0
    return x

def _hsv_to_rgb(h: float, s: float, v: float) -> RGB:
    h=(h%1.0)*6.0
    i=int(h)%6
    f=h-float(i)
    p=v*(1.0-s)
    q=v*(1.0-f*s)
    t=v*(1.0-(1.0-f)*s)
    if i==0: r,g,b=v,t,p
    elif i==1: r,g,b=q,v,p
    elif i==2: r,g,b=p,v,t
    elif i==3: r,g,b=p,q,v
    elif i==4: r,g,b=t,p,v
    else: r,g,b=v,p,q
    return (int(r*255)&255,int(g*255)&255,int(b*255)&255)

def _preview_emit(*, num_leds:int, params:dict, t:float, state=None) -> List[RGB]:
    n=max(1,int(num_leds))
    br=_clamp01(float(params.get("brightness",1.0)))
    speed=max(0.1,float(params.get("speed",1.0)))
    softness=_clamp01(float(params.get("softness",0.45)))
    density=_clamp01(float(params.get("density",0.55))) # complexity
    width=_clamp01(float(params.get("width",0.35)))     # stripe width
    if width < 0.05: width = 0.05

    ev = (params.get("_audio_events") or {})
    # left/right energies + beats
    el=float(ev.get("energy_l",0.0) or 0.0)
    er=float(ev.get("energy_r",0.0) or 0.0)
    beat_l=float(ev.get("beat_l",0.0) or 0.0)
    beat_r=float(ev.get("beat_r",0.0) or 0.0)
    sec_change=float((params.get("_audio_tempo") or {}).get("sec_change",0.0) or 0.0)

    if state is None or not isinstance(state, dict):
        state={"call":0.0,"resp":0.0,"swap":0.0,"hseed":0.0}
    if beat_l>0.5: state["call"]=1.0
    if beat_r>0.5: state["resp"]=1.0
    if sec_change>0.5:
        # section change flips roles and shifts palette
        state["swap"]=1.0-state["swap"]
        state["hseed"]=(state["hseed"]+0.17)%1.0

    # decay flashes
    decay=(0.55+1.6*(1.0-softness))*(1.0/60.0)
    state["call"]=max(0.0,state["call"]-decay)
    state["resp"]=max(0.0,state["resp"]-decay)

    swap=state["swap"]
    # role-weighted energies
    call_e = (1.0-swap)*el + swap*er
    resp_e = (1.0-swap)*er + swap*el

    # pattern params
    freq = (2.0 + 16.0*(0.25 + density))*(0.35+0.65*(1.0-width))
    rate = (0.10 + 2.2*speed)*(0.35+1.4*max(call_e, resp_e))

    base_h = (0.58 + state["hseed"]) % 1.0
    out=[]
    for i in range(n):
        x=i/max(1.0,(n-1))
        w=2*math.pi*(x*freq + t*rate)
        a=0.5+0.5*math.sin(w)
        a=a**(0.65+2.4*softness)
        # left half = call, right half = response, with crossfade
        lr = x
        mix = 1.0 if lr<0.5 else 0.0
        mix = _clamp01(mix*2.0)  # 1 on left, 0 on right
        energy = mix*call_e + (1.0-mix)*resp_e
        flash = mix*state["call"] + (1.0-mix)*state["resp"]
        v = br * _clamp01(0.10 + 0.70*a*energy + 0.35*flash)
        h = (base_h + 0.18*mix + 0.22*(1.0-mix) + 0.08*math.sin(w*0.5)) % 1.0
        out.append(_hsv_to_rgb(h, 1.0, v))
    return out

def _arduino_emit(*, layout:dict, params:dict) -> str:
    n=int(layout["num_leds"]); pin=int(layout["led_pin"])
    br=float(params.get("brightness",1.0))
    speed=max(0.1,float(params.get("speed",1.0)))
    softness=float(params.get("softness",0.45))
    density=float(params.get("density",0.55))
    width=float(params.get("width",0.35))
    br=max(0.0,min(1.0,br))
    softness=max(0.0,min(1.0,softness))
    density=max(0.0,min(1.0,density))
    width=max(0.05,min(1.0,width))

    # keep MCU logic simple: left/right energies + left/right beat triggers from low bands derivative
    alpha = 0.10 + 0.35*softness
    freq = (2.0 + 16.0*(0.25 + density))*(0.35+0.65*(1.0-width))

    return f"""// Generated by Modulo (Call & Response - Stereo14)
#include <FastLED.h>
#include <math.h>

#define NUM_LEDS {n}
#define LED_PIN {pin}
CRGB leds[NUM_LEDS];

// MSGEQ7 pins (default)
const int RESET_PIN = 5;
const int STROBE_PIN = 4;
const int LEFT_PIN = A0;
const int RIGHT_PIN = A1;

float le=0.0f, re=0.0f;
float le_prev=0.0f, re_prev=0.0f;
float le_pk=0.0f, re_pk=0.0f;
int le_cd=0, re_cd=0;
float call_flash=0.0f, resp_flash=0.0f;
float swap_role=0.0f;
float hseed=0.0f;

static inline float clamp01(float x) {{
  if (x<0.0f) return 0.0f;
  if (x>1.0f) return 1.0f;
  return x;
}}
static inline float read01(int pin) {{
  int v=analogRead(pin);
  return clamp01((float)v/1023.0f);
}}
static inline void hsv_to_rgb(float h, float s, float v, uint8_t* r, uint8_t* g, uint8_t* b) {{
  float hh=fmodf(h,1.0f)*6.0f;
  int i=(int)floorf(hh)%6;
  float f=hh-(float)i;
  float p=v*(1.0f-s);
  float q=v*(1.0f-f*s);
  float t=v*(1.0f-(1.0f-f)*s);
  float rr,gg,bb;
  if (i==0) {{ rr=v; gg=t; bb=p; }}
  else if (i==1) {{ rr=q; gg=v; bb=p; }}
  else if (i==2) {{ rr=p; gg=v; bb=t; }}
  else if (i==3) {{ rr=p; gg=q; bb=v; }}
  else if (i==4) {{ rr=t; gg=p; bb=v; }}
  else {{ rr=v; gg=p; bb=q; }}
  *r=(uint8_t)(rr*255.0f); *g=(uint8_t)(gg*255.0f); *b=(uint8_t)(bb*255.0f);
}}

void setup() {{
  FastLED.addLeds<WS2812B, LED_PIN, GRB>(leds, NUM_LEDS);
  FastLED.setBrightness(255);
  pinMode(RESET_PIN, OUTPUT);
  pinMode(STROBE_PIN, OUTPUT);
  digitalWrite(RESET_PIN, LOW);
  digitalWrite(STROBE_PIN, HIGH);
}}

void loop() {{
  // read 7+7 and compute energies
  float L[7], R[7];
  digitalWrite(RESET_PIN, HIGH); delayMicroseconds(5); digitalWrite(RESET_PIN, LOW);
  for (int i=0;i<7;i++) {{
    digitalWrite(STROBE_PIN, LOW); delayMicroseconds(30);
    L[i]=read01(LEFT_PIN);
    R[i]=read01(RIGHT_PIN);
    digitalWrite(STROBE_PIN, HIGH);
  }}
  float lsum=0.0f, rsum=0.0f;
  for (int i=0;i<7;i++) {{ lsum+=L[i]; rsum+=R[i]; }}
  float lraw=lsum/7.0f;
  float rraw=rsum/7.0f;

  le_prev=le; re_prev=re;
  le=(1.0f-{alpha}f)*le + {alpha}f*lraw;
  re=(1.0f-{alpha}f)*re + {alpha}f*rraw;

  float dL=le-le_prev;
  float dR=re-re_prev;
  le_pk=fmaxf(le_pk-0.020f, le);
  re_pk=fmaxf(re_pk-0.020f, re);

  bool beatL=false, beatR=false;
  float thrL=0.05f + le_pk*0.20f;
  float thrR=0.05f + re_pk*0.20f;

  if (le_cd>0) le_cd--; else if (dL>thrL) {{ beatL=true; le_cd=4; }}
  if (re_cd>0) re_cd--; else if (dR>thrR) {{ beatR=true; re_cd=4; }}

  if (beatL) call_flash=1.0f;
  if (beatR) resp_flash=1.0f;

  // crude "section" flip: if sustained energy high for a while, swap occasionally
  static int sec_cnt=0;
  if ((le+re)*0.5f > 0.65f) sec_cnt++; else sec_cnt=0;
  if (sec_cnt>240) {{ // ~4s at 60fps
    sec_cnt=0;
    swap_role = 1.0f - swap_role;
    hseed = fmodf(hseed + 0.17f, 1.0f);
  }}

  float decay=(0.55f+1.6f*(1.0f-(float){softness}f))*(1.0f/60.0f);
  call_flash=fmaxf(0.0f, call_flash-decay);
  resp_flash=fmaxf(0.0f, resp_flash-decay);

  float call_e = (1.0f-swap_role)*le + swap_role*re;
  float resp_e = (1.0f-swap_role)*re + swap_role*le;

  float br=clamp01((float){br}f);
  float softness=clamp01((float){softness}f);
  float speed=(float){speed}f;

  float rate=(0.10f + 2.2f*speed)*(0.35f+1.4f*fmaxf(call_e,resp_e));
  float base_h=fmodf(0.58f + hseed, 1.0f);

  float tt=millis()/1000.0f;

  for (int i=0;i<NUM_LEDS;i++) {{
    float x=(NUM_LEDS<=1)?0.0f:((float)i/(float)(NUM_LEDS-1));
    float w=2.0f*3.1415926f*(x*(float){freq}f + tt*rate);
    float a=0.5f+0.5f*sinf(w);
    a=powf(a, 0.65f+2.4f*softness);

    float mix = (x<0.5f) ? clamp01(2.0f*(0.5f-x)) : 0.0f; // 1 on left -> 0 on right
    float energy = mix*call_e + (1.0f-mix)*resp_e;
    float flash = mix*call_flash + (1.0f-mix)*resp_flash;
    float v = clamp01(br*(0.10f + 0.70f*a*energy + 0.35f*flash));

    float h = fmodf(base_h + 0.18f*mix + 0.22f*(1.0f-mix) + 0.08f*sinf(w*0.5f), 1.0f);
    uint8_t r,g,b; hsv_to_rgb(h,1.0f,v,&r,&g,&b);
    leds[i]=CRGB(r,g,b);
  }}

  FastLED.show();
  delay(1);
}}
"""

def register_call_response():
    return register(BehaviorDef(
        "call_response",
        title="Call & Response (Stereo 14)",
        uses=USES,
        preview_emit=_preview_emit,
        arduino_emit=_arduino_emit
    ))
