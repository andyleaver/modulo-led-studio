from __future__ import annotations
SHIPPED = True

from typing import List, Tuple
import math
from behaviors.registry import BehaviorDef, register

RGB = Tuple[int,int,int]
USES = ["brightness","speed","softness","density","width"]  # uses existing knobs; zone split is implicit

def _clamp01(x: float) -> float:
    if x < 0.0: return 0.0
    if x > 1.0: return 1.0
    return x

def _hsv_to_rgb(h: float, s: float, v: float) -> RGB:
    h=(h%1.0)*6.0
    i=int(h)%6
    f=h-float(i)
    p=v*(1.0-s)
    q=v*(1.0-f*s)
    t=v*(1.0-(1.0-f)*s)
    if i==0: r,g,b=v,t,p
    elif i==1: r,g,b=q,v,p
    elif i==2: r,g,b=p,v,t
    elif i==3: r,g,b=p,q,v
    elif i==4: r,g,b=t,p,v
    else: r,g,b=v,p,q
    return (int(r*255)&255,int(g*255)&255,int(b*255)&255)

def _zones_from_project(params: dict, n: int) -> List[tuple[int,int]]:
    proj = params.get("_project") or {}
    zones = proj.get("zones") or []
    z = []
    for it in zones[:8]:
        try:
            a=int(it.get("start",0)); b=int(it.get("end",0))
            if a> b: a,b=b,a
            a=max(0,min(n-1,a)); b=max(0,min(n-1,b))
            z.append((a,b))
        except Exception:
            pass
    if len(z) >= 3:
        return z
    # fallback: thirds
    if n <= 0: return [(0,0),(0,0),(0,0)]
    t1 = max(0, (n//3)-1)
    t2 = max(0, (2*n//3)-1)
    return [(0,t1), (t1+1,t2), (t2+1,n-1)]

def _preview_emit(*, num_leds: int, params: dict, t: float, state=None) -> List[RGB]:
    n=max(1,int(num_leds))
    br=_clamp01(float(params.get("brightness",1.0)))
    speed=max(0.1,float(params.get("speed",1.0)))
    softness=_clamp01(float(params.get("softness",0.45)))
    density=_clamp01(float(params.get("density",0.55))) # response curve
    width=_clamp01(float(params.get("width",0.35)))     # zone edge softness

    ev = (params.get("_audio_events") or {})
    # bass/mid/high from stereo 14
    bass = 0.25*(
        float(ev.get("l0_level",0.0) or 0.0) + float(ev.get("l1_level",0.0) or 0.0) +
        float(ev.get("r0_level",0.0) or 0.0) + float(ev.get("r1_level",0.0) or 0.0)
    )
    mid = (sum(float(ev.get(f"l{i}_level",0.0) or 0.0) for i in (2,3,4)) +
           sum(float(ev.get(f"r{i}_level",0.0) or 0.0) for i in (2,3,4))) / 6.0
    high = (sum(float(ev.get(f"l{i}_level",0.0) or 0.0) for i in (5,6)) +
            sum(float(ev.get(f"r{i}_level",0.0) or 0.0) for i in (5,6))) / 4.0

    # curve / dynamics
    def curve(x: float) -> float:
        x=_clamp01(x)
        g = 0.65 + 2.2*softness
        x = x**(0.35 + 1.9*(1.0-density))
        return x**(1.0/g)

    bass, mid, high = curve(bass), curve(mid), curve(high)

    z0,z1,z2 = _zones_from_project(params, n)[:3]

    # edge softness: small feather at boundaries
    feather = max(1, int(1 + width*0.10*n))
    out=[(0,0,0) for _ in range(n)]

    # palette slowly drifts; speed affects drift
    base=(0.02 + 0.08*math.sin(t*(0.25+0.9*speed)))%1.0
    cols=[(base+0.00)%1.0, (base+0.33)%1.0, (base+0.66)%1.0]
    amps=[bass, mid, high]

    def paint(a:int,b:int,amp:float,hue:float):
        if b < a: return
        for i in range(a,b+1):
            # feather boundaries
            w=1.0
            if i-a < feather: w *= (i-a+1)/feather
            if b-i < feather: w *= (b-i+1)/feather
            v = br * amp * w
            if v <= 0.001: 
                continue
            out[i]=_hsv_to_rgb(hue, 1.0, _clamp01(v))

    paint(z0[0],z0[1],amps[0],cols[0])
    paint(z1[0],z1[1],amps[1],cols[1])
    paint(z2[0],z2[1],amps[2],cols[2])
    return out

def _arduino_emit(*, layout: dict, params: dict) -> str:
    n=int(layout["num_leds"]); pin=int(layout["led_pin"])
    br=float(params.get("brightness",1.0))
    speed=max(0.1,float(params.get("speed",1.0)))
    softness=float(params.get("softness",0.45))
    density=float(params.get("density",0.55))
    width=float(params.get("width",0.35))
    br=max(0.0,min(1.0,br))
    softness=max(0.0,min(1.0,softness))
    density=max(0.0,min(1.0,density))
    width=max(0.0,min(1.0,width))

    # zones from project if available at export time (baked), else thirds
    n_ = max(1,n)
    proj = params.get("_project") or {}
    zones = proj.get("zones") or []
    def clampi(x): 
        if x<0: return 0
        if x>n_-1: return n_-1
        return x
    z=[]
    for it in zones[:8]:
        try:
            a=int(it.get("start",0)); b=int(it.get("end",0))
            if a>b: a,b=b,a
            z.append((clampi(a),clampi(b)))
        except Exception:
            pass
    if len(z) < 3:
        t1=max(0,(n_//3)-1); t2=max(0,(2*n_//3)-1)
        z=[(0,t1),(t1+1,t2),(t2+1,n_-1)]
    (z0a,z0b),(z1a,z1b),(z2a,z2b)=z[:3]

    feather = max(1, int(1 + width*0.10*n_))

    return f"""// Generated by Modulo (Audio Zone EQ - Stereo14 -> 3 Zones)
#include <FastLED.h>
#include <math.h>

#define NUM_LEDS {n}
#define LED_PIN {pin}
CRGB leds[NUM_LEDS];

// MSGEQ7 pins (default)
const int RESET_PIN = 5;
const int STROBE_PIN = 4;
const int LEFT_PIN = A0;
const int RIGHT_PIN = A1;

static inline float clamp01(float x) {{
  if (x<0.0f) return 0.0f;
  if (x>1.0f) return 1.0f;
  return x;
}}
static inline float read01(int pin) {{
  int v=analogRead(pin);
  return clamp01((float)v/1023.0f);
}}
static inline void hsv_to_rgb(float h, float s, float v, uint8_t* r, uint8_t* g, uint8_t* b) {{
  float hh=fmodf(h,1.0f)*6.0f;
  int i=(int)floorf(hh)%6;
  float f=hh-(float)i;
  float p=v*(1.0f-s);
  float q=v*(1.0f-f*s);
  float t=v*(1.0f-(1.0f-f)*s);
  float rr,gg,bb;
  if (i==0) {{ rr=v; gg=t; bb=p; }}
  else if (i==1) {{ rr=q; gg=v; bb=p; }}
  else if (i==2) {{ rr=p; gg=v; bb=t; }}
  else if (i==3) {{ rr=p; gg=q; bb=v; }}
  else if (i==4) {{ rr=t; gg=p; bb=v; }}
  else {{ rr=v; gg=p; bb=q; }}
  *r=(uint8_t)(rr*255.0f); *g=(uint8_t)(gg*255.0f); *b=(uint8_t)(bb*255.0f);
}}

static inline float curve(float x) {{
  x=clamp01(x);
  float softness=clamp01((float){softness}f);
  float density=clamp01((float){density}f);
  float g = 0.65f + 2.2f*softness;
  x = powf(x, (0.35f + 1.9f*(1.0f-density)));
  return powf(x, (1.0f/g));
}}

static inline float feather_w(int i, int a, int b) {{
  int f={feather};
  float w=1.0f;
  if (i-a < f) w *= (float)(i-a+1)/(float)f;
  if (b-i < f) w *= (float)(b-i+1)/(float)f;
  return w;
}}

void setup() {{
  FastLED.addLeds<WS2812B, LED_PIN, GRB>(leds, NUM_LEDS);
  FastLED.setBrightness(255);
  pinMode(RESET_PIN, OUTPUT);
  pinMode(STROBE_PIN, OUTPUT);
  digitalWrite(RESET_PIN, LOW);
  digitalWrite(STROBE_PIN, HIGH);
}}

void loop() {{
  float L[7], R[7];
  digitalWrite(RESET_PIN, HIGH); delayMicroseconds(5); digitalWrite(RESET_PIN, LOW);
  for (int i=0;i<7;i++) {{
    digitalWrite(STROBE_PIN, LOW); delayMicroseconds(30);
    L[i]=read01(LEFT_PIN);
    R[i]=read01(RIGHT_PIN);
    digitalWrite(STROBE_PIN, HIGH);
  }}

  float bass = 0.25f*(L[0]+L[1]+R[0]+R[1]);
  float mid  = (L[2]+L[3]+L[4]+R[2]+R[3]+R[4])/6.0f;
  float high = (L[5]+L[6]+R[5]+R[6])/4.0f;

  bass=curve(bass); mid=curve(mid); high=curve(high);

  float tt=millis()/1000.0f;
  float base=fmodf(0.02f + 0.08f*sinf(tt*(0.25f+0.9f*(float){speed}f)), 1.0f);
  float h0=base;
  float h1=fmodf(base+0.33f,1.0f);
  float h2=fmodf(base+0.66f,1.0f);

  float br=clamp01((float){br}f);

  for (int i=0;i<NUM_LEDS;i++) {{
    leds[i]=CRGB(0,0,0);
  }}

  // zone 0
  for (int i={z0a}; i<={z0b} && i<NUM_LEDS; i++) {{
    float v=clamp01(br*bass*feather_w(i,{z0a},{z0b}));
    uint8_t r,g,b; hsv_to_rgb(h0,1.0f,v,&r,&g,&b);
    leds[i]=CRGB(r,g,b);
  }}
  // zone 1
  for (int i={z1a}; i<={z1b} && i<NUM_LEDS; i++) {{
    float v=clamp01(br*mid*feather_w(i,{z1a},{z1b}));
    uint8_t r,g,b; hsv_to_rgb(h1,1.0f,v,&r,&g,&b);
    leds[i]=CRGB(r,g,b);
  }}
  // zone 2
  for (int i={z2a}; i<={z2b} && i<NUM_LEDS; i++) {{
    float v=clamp01(br*high*feather_w(i,{z2a},{z2b}));
    uint8_t r,g,b; hsv_to_rgb(h2,1.0f,v,&r,&g,&b);
    leds[i]=CRGB(r,g,b);
  }}

  FastLED.show();
  delay(1);
}}
"""

def register_audio_zone_eq():
    return register(BehaviorDef(
        "audio_zone_eq",
        title="Audio Zone EQ (Bass/Mid/High Zones)",
        uses=USES,
        preview_emit=_preview_emit,
        arduino_emit=_arduino_emit,
    ))
