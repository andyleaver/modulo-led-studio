from __future__ import annotations
from typing import List, Tuple
import math

from behaviors.registry import BehaviorDef, register

RGB = Tuple[int,int,int]

# Shipped effect (included in behaviors/auto_load.py)
SHIPPED = True

USES = ["color", "brightness"]
def _apply_brightness(rgb, br: float):
    try: br = float(br)
    except Exception: br = 1.0
    br = 0.0 if br < 0 else (1.0 if br > 1.0 else br)
    r,g,b = rgb
    return (int(r*br)&255, int(g*br)&255, int(b*br)&255)

def _preview_emit(*, num_leds: int, params: dict, t: float) -> List[RGB]:
    n = max(1, int(num_leds))
    c = params.get("color", (255,0,0))
    br = params.get("brightness", 1.0)
    speed = float(params.get("speed", 1.0))
    # Width semantics (Phase A): the global param registry defines `width` as a pixel-ish scalar
    # (min=1, max=200). Older effects used width as a 0..1 fraction.
    # To keep both behaviors usable:
    #   - width <= 1.0  -> treat as fraction of strip length
    #   - width >  1.0  -> treat as pixels
    width = float(params.get("width", 6.0))
    if width <= 1.0:
        w = int(round(max(0.01, width) * n))
    else:
        w = int(round(width))
    if w < 1:
        w = 1
    if w > n:
        w = n
    pos = int((t * speed * 10.0) % n)  # 10 is just a friendly scale

    base = _apply_brightness((int(c[0])&255, int(c[1])&255, int(c[2])&255), br)
    off = (0,0,0)
    out = [off]*n
    for i in range(w):
        out[(pos+i) % n] = base
    return out

def _arduino_emit(*, layout: dict, params: dict) -> str:
    # Phase 3E: Export single-layer Chase (strip-linear). If used with cells, it's linear order.
    n = int(layout["num_leds"])
    pin = int(layout["led_pin"])
    c = params.get("color",(255,0,0))
    br = float(params.get("brightness", 1.0))
    speed = float(params.get("speed", 1.0))
    width = float(params.get("width", 6.0))

    # clamp
    br = 0.0 if br < 0 else (1.0 if br > 1.0 else br)
    if width <= 1.0:
        w = int(round(max(0.01, width) * n))
    else:
        w = int(round(width))
    if w < 1: w = 1
    if w > n: w = n

    r = int(int(c[0]) * br) & 255
    g = int(int(c[1]) * br) & 255
    b = int(int(c[2]) * br) & 255

    # map speed(0..10) to ms per step roughly
    step_ms = int(max(1.0, 120.0 / max(0.1, speed)))

    return f"""// Generated by Modulo (Phase 3E: Chase)
#include <FastLED.h>

#define NUM_LEDS {n}
#define LED_PIN {pin}
CRGB leds[NUM_LEDS];

unsigned long lastStep = 0;
int pos = 0;

void setup() {{
  FastLED.addLeds<WS2812B, LED_PIN, GRB>(leds, NUM_LEDS);
  FastLED.setBrightness(255);
}}

void loop() {{
  unsigned long now = millis();
  if (now - lastStep >= (unsigned long){step_ms}) {{
    lastStep = now;
    pos = (pos + 1) % NUM_LEDS;
  }}

  for (int i=0; i<NUM_LEDS; i++) {{
    leds[i] = CRGB(0,0,0);
  }}

  for (int k=0; k<{w}; k++) {{
    int idx = (pos + k) % NUM_LEDS;
    leds[idx] = CRGB({r},{g},{b});
  }}

  FastLED.show();
  delay(1);
}}
"""

def register_chase():
    return register(BehaviorDef(
        "chase",
        title="Chase",
        uses=["color","brightness","speed","width"],
        preview_emit=_preview_emit,
        arduino_emit=_arduino_emit,
    ))
