from __future__ import annotations
SHIPPED = True

from typing import List, Tuple
import math
from behaviors.registry import BehaviorDef, register

RGB=Tuple[int,int,int]
USES=["brightness","speed","softness","density","width"]

def _clamp01(x: float) -> float:
    if x<0.0: return 0.0
    if x>1.0: return 1.0
    return x

def _hsv_to_rgb(h: float, s: float, v: float) -> RGB:
    h=(h%1.0)*6.0
    i=int(h)%6
    f=h-float(i)
    p=v*(1.0-s)
    q=v*(1.0-f*s)
    t=v*(1.0-(1.0-f)*s)
    if i==0: r,g,b=v,t,p
    elif i==1: r,g,b=q,v,p
    elif i==2: r,g,b=p,v,t
    elif i==3: r,g,b=p,q,v
    elif i==4: r,g,b=t,p,v
    else: r,g,b=v,p,q
    return (int(r*255)&255,int(g*255)&255,int(b*255)&255)

def _hash_u32(x: int) -> int:
    x = (x ^ 0x9E3779B9) & 0xFFFFFFFF
    x = (x * 0x85EBCA6B) & 0xFFFFFFFF
    x = (x ^ (x >> 13)) & 0xFFFFFFFF
    x = (x * 0xC2B2AE35) & 0xFFFFFFFF
    x = (x ^ (x >> 16)) & 0xFFFFFFFF
    return x

def _u01(h: int) -> float:
    return float(h & 0xFFFFFF) / float(0x1000000)

def _preview_emit(*, num_leds:int, params:dict, t:float, state=None)->List[RGB]:
    n=max(1,int(num_leds))
    br=_clamp01(float(params.get("brightness",1.0)))
    speed=max(0.1,float(params.get("speed",1.0)))
    softness=_clamp01(float(params.get("softness",0.45)))
    density=_clamp01(float(params.get("density",0.55))) # sensitivity/spawn
    width=_clamp01(float(params.get("width",0.35)))     # spark size
    if width<0.05: width=0.05

    ev=(params.get("_audio_events") or {})
    # snare = mid transient (L3/L4/R3/R4)
    sn=max(float(ev.get("l3_tr",0.0) or 0.0), float(ev.get("l4_tr",0.0) or 0.0),
           float(ev.get("r3_tr",0.0) or 0.0), float(ev.get("r4_tr",0.0) or 0.0))

    if state is None or not isinstance(state, dict):
        state={"S":[]}  # (x, life)
    S=state["S"]

    if sn>0.5:
        # spawn a bunch deterministically
        bucket=int(t*30.0*(0.6+1.6*speed))
        for k in range(2 + int(6*density)):
            h=_hash_u32(bucket ^ (k*1337))
            x=_u01(h)
            life=0.35 + 0.55*_u01(_hash_u32(h^0xABCD))
            S.append([x, life])

    dt=1.0/60.0
    decay=(0.85+2.2*(1.0-softness))
    sig=(0.004 + width*0.018)*(0.8+1.6*softness)

    out=[(0,0,0) for _ in range(n)]
    new=[]
    for x,life in S:
        life -= decay*dt
        if life<=0: 
            continue
        new.append([x,life])
        hue = 0.58 + 0.12*math.sin(t*1.4)
        c=_hsv_to_rgb(hue, 0.25, 1.0)
        for i in range(n):
            xx=i/max(1.0,(n-1))
            d=abs(xx-x); d=min(d,1.0-d)
            a=math.exp(-(d*d)/(2.0*sig*sig)) * life
            if a<0.003: 
                continue
            out[i]=(min(255,out[i][0]+int(c[0]*br*a)),
                   min(255,out[i][1]+int(c[1]*br*a)),
                   min(255,out[i][2]+int(c[2]*br*a)))
    state["S"]=new[-240:]
    return out

def _arduino_emit(*, layout:dict, params:dict)->str:
    n=int(layout["num_leds"]); pin=int(layout["led_pin"])
    br=float(params.get("brightness",1.0))
    speed=max(0.1,float(params.get("speed",1.0)))
    softness=float(params.get("softness",0.45))
    density=float(params.get("density",0.55))
    width=float(params.get("width",0.35))
    if br<0: br=0.0
    if br>1: br=1.0
    if softness<0: softness=0.0
    if softness>1: softness=1.0
    if density<0: density=0.0
    if density>1: density=1.0
    if width<0.05: width=0.05
    if width>1: width=1.0

    alpha=0.10 + 0.35*softness
    decay=(0.85+2.2*(1.0-softness))
    sig=(0.004 + width*0.018)*(0.8+1.6*softness)
    # particle pool
    MAXS=240

    return f"""// Generated by Modulo (Snare Spark)
#include <FastLED.h>
#include <math.h>

#define NUM_LEDS {n}
#define LED_PIN {pin}
CRGB leds[NUM_LEDS];

// MSGEQ7 pins (default)
const int RESET_PIN = 5;
const int STROBE_PIN = 4;
const int LEFT_PIN = A0;
const int RIGHT_PIN = A1;

// band state
float B[14]={{0}};
float Pk[14]={{0}};
int cd[14]={{0}};

struct Spark {{ float x; float life; bool alive; }};
Spark S[{MAXS}];

static inline float clamp01(float x) {{
  if (x<0.0f) return 0.0f;
  if (x>1.0f) return 1.0f;
  return x;
}}
static inline float read01(int pin) {{
  int v=analogRead(pin);
  return clamp01((float)v/1023.0f);
}}
static inline uint32_t hash_u32(uint32_t x) {{
  x ^= 0x9E3779B9u;
  x *= 0x85EBCA6Bu;
  x ^= (x >> 13);
  x *= 0xC2B2AE35u;
  x ^= (x >> 16);
  return x;
}}
static inline float u01(uint32_t h) {{
  return (float)(h & 0xFFFFFFu)/16777216.0f;
}}
static inline void add_rgb(uint8_t* r, uint8_t* g, uint8_t* b, float ar, float ag, float ab) {{
  float rr=fminf(255.0f,(float)(*r)+ar);
  float gg=fminf(255.0f,(float)(*g)+ag);
  float bb=fminf(255.0f,(float)(*b)+ab);
  *r=(uint8_t)rr; *g=(uint8_t)gg; *b=(uint8_t)bb;
}}
static inline void hsv_to_rgb(float h, float s, float v, uint8_t* r, uint8_t* g, uint8_t* b) {{
  float hh=fmodf(h,1.0f)*6.0f;
  int i=(int)floorf(hh)%6;
  float f=hh-(float)i;
  float p=v*(1.0f-s);
  float q=v*(1.0f-f*s);
  float t=v*(1.0f-(1.0f-f)*s);
  float rr,gg,bb;
  if (i==0) {{ rr=v; gg=t; bb=p; }}
  else if (i==1) {{ rr=q; gg=v; bb=p; }}
  else if (i==2) {{ rr=p; gg=v; bb=t; }}
  else if (i==3) {{ rr=p; gg=q; bb=v; }}
  else if (i==4) {{ rr=t; gg=p; bb=v; }}
  else {{ rr=v; gg=p; bb=q; }}
  *r=(uint8_t)(rr*255.0f); *g=(uint8_t)(gg*255.0f); *b=(uint8_t)(bb*255.0f);
}}

int allocSpark() {{
  for (int i=0;i<{MAXS};i++) if (!S[i].alive) return i;
  return -1;
}}

void setup() {{
  FastLED.addLeds<WS2812B, LED_PIN, GRB>(leds, NUM_LEDS);
  FastLED.setBrightness(255);
  pinMode(RESET_PIN, OUTPUT);
  pinMode(STROBE_PIN, OUTPUT);
  digitalWrite(RESET_PIN, LOW);
  digitalWrite(STROBE_PIN, HIGH);
  for (int i=0;i<{MAXS};i++) S[i].alive=false;
}}

void loop() {{
  float raw[14];
  digitalWrite(RESET_PIN, HIGH); delayMicroseconds(5); digitalWrite(RESET_PIN, LOW);
  for (int i=0;i<7;i++) {{
    digitalWrite(STROBE_PIN, LOW); delayMicroseconds(30);
    raw[i]=read01(LEFT_PIN);
    raw[i+7]=read01(RIGHT_PIN);
    digitalWrite(STROBE_PIN, HIGH);
  }}

  // update transient state
  for (int i=0;i<14;i++) {{
    float prev=B[i];
    B[i]=(1.0f-{alpha}f)*B[i] + {alpha}f*raw[i];
    float d=B[i]-prev;
    Pk[i]=fmaxf(Pk[i]-0.020f, B[i]);
    if (cd[i]>0) {{ cd[i]--; continue; }}
    float thr = 0.05f + Pk[i]*0.25f;
    if (d > thr) cd[i]=4;
  }}

  bool sn = (cd[3]==4)||(cd[4]==4)||(cd[10]==4)||(cd[11]==4);
  if (sn) {{
    uint32_t bucket = (uint32_t)((millis()/1000.0f) * (30.0f*(0.6f+1.6f*(float){speed}f)));
    int count = 2 + (int)lroundf(6.0f*(float){density}f);
    for (int k=0;k<count;k++) {{
      int idx=allocSpark();
      if (idx<0) break;
      uint32_t h=hash_u32(bucket ^ (uint32_t)(k*1337));
      S[idx].x=u01(h);
      S[idx].life=0.35f + 0.55f*u01(hash_u32(h^0xABCDu));
      S[idx].alive=true;
    }}
  }}

  // clear
  for (int i=0;i<NUM_LEDS;i++) leds[i]=CRGB(0,0,0);

  const float dt=1.0f/60.0f;
  float br=clamp01((float){br}f);
  float decay=(float){decay}f;
  float sig=(float){sig}f;

  float tt=millis()/1000.0f;
  float hue=0.58f + 0.12f*sinf(tt*1.4f);
  uint8_t pr,pg,pb;
  hsv_to_rgb(hue,0.25f,1.0f,&pr,&pg,&pb);

  for (int si=0; si<{MAXS}; si++) {{
    if (!S[si].alive) continue;
    S[si].life -= decay*dt;
    if (S[si].life<=0.0f) {{ S[si].alive=false; continue; }}

    for (int i=0;i<NUM_LEDS;i++) {{
      float x=(NUM_LEDS<=1)?0.0f:((float)i/(float)(NUM_LEDS-1));
      float d=fabsf(x - S[si].x);
      d=fminf(d,1.0f-d);
      float a=expf(-(d*d)/(2.0f*sig*sig)) * S[si].life;
      if (a<0.003f) continue;
      float kf=br*a;
      add_rgb(&leds[i].r,&leds[i].g,&leds[i].b, (float)pr*kf,(float)pg*kf,(float)pb*kf);
    }}
  }}

  FastLED.show();
  delay(1);
}}
"""

def register_snare_spark():
    return register(BehaviorDef(
        "snare_spark",
        title="Snare Spark (Audio Events)",
        uses=USES,
        preview_emit=_preview_emit,
        arduino_emit=_arduino_emit,
    ))
