from __future__ import annotations
SHIPPED = True

from typing import List, Tuple
import math

from behaviors.registry import BehaviorDef, register

RGB = Tuple[int,int,int]

def _clamp01(x: float) -> float:
    if x < 0.0: return 0.0
    if x > 1.0: return 1.0
    return x

def _hash_u32(x: int) -> int:
    x = (x ^ 0x9E3779B9) & 0xFFFFFFFF
    x = (x * 0x85EBCA6B) & 0xFFFFFFFF
    x = (x ^ (x >> 13)) & 0xFFFFFFFF
    x = (x * 0xC2B2AE35) & 0xFFFFFFFF
    x = (x ^ (x >> 16)) & 0xFFFFFFFF
    return x

def _u01(h: int) -> float:
    return float(h & 0xFFFFFF) / float(0x1000000)

def _hsv_to_rgb(h: float, s: float, v: float) -> RGB:
    h = (h % 1.0) * 6.0
    i = int(h) % 6
    f = h - float(i)
    p = v * (1.0 - s)
    q = v * (1.0 - f * s)
    t = v * (1.0 - (1.0 - f) * s)
    if i == 0: r,g,b = v,t,p
    elif i == 1: r,g,b = q,v,p
    elif i == 2: r,g,b = p,v,t
    elif i == 3: r,g,b = p,q,v
    elif i == 4: r,g,b = t,p,v
    else: r,g,b = v,p,q
    return (int(r*255)&255, int(g*255)&255, int(b*255)&255)

def _add(a: RGB, b: RGB) -> RGB:
    return (min(255,a[0]+b[0]), min(255,a[1]+b[1]), min(255,a[2]+b[2]))

USES = ["brightness","speed","density","width","softness"]

def _preview_emit(*, num_leds: int, params: dict, t: float) -> List[RGB]:
    n = max(1, int(num_leds))
    br = _clamp01(float(params.get("brightness", 1.0)))
    speed = max(0.1, float(params.get("speed", 1.0)))
    density = _clamp01(float(params.get("density", 0.55)))  # city density
    width = _clamp01(float(params.get("width", 0.35)))      # block size
    softness = _clamp01(float(params.get("softness", 0.45)))# glow
    if width < 0.05: width = 0.05

    blocks = 6 + int(round((1.0/width)*2.5))
    if blocks < 6: blocks = 6
    if blocks > 30: blocks = 30
    glow = 0.6 + softness*2.2
    scan = 0.5 + speed*0.6

    out=[(0,0,0) for _ in range(n)]
    # base gradient background
    for i in range(n):
        x = i / max(1.0,(n-1))
        hue = (0.78 + 0.1*math.sin(t*speed*0.05) + x*0.15) % 1.0
        r,g,b = _hsv_to_rgb(hue, 1.0, br*(0.06 + 0.10*math.sin(2.0*math.pi*(x + t*speed*0.02))*0.5))
        out[i]=_add(out[i], (r,g,b))

    bucket = int(t*scan)
    u = (t*scan) - bucket
    for b in range(blocks):
        h = _hash_u32(bucket ^ (b*131))
        if _u01(h) > (0.25 + 0.65*density):
            continue
        x0 = _u01(h)
        w = 0.03 + width*(0.05 + 0.12*_u01(_hash_u32(h ^ 0xBEEF)))
        hue = (0.85 + 0.25*_u01(_hash_u32(h ^ 0x1234)) + t*speed*0.03) % 1.0
        pr,pg,pb = _hsv_to_rgb(hue, 1.0, 1.0)
        amp = (0.35 + 0.65*_u01(_hash_u32(h ^ 0x4444))) * (0.5 + 0.5*math.sin(2.0*math.pi*(u + b*0.17)))
        for i in range(n):
            x = i / max(1.0,(n-1))
            d = abs(x - x0)
            d = min(d, 1.0-d)
            a = max(0.0, 1.0 - d/max(1e-6,w))
            a = (a**2) * amp
            # glow
            a *= math.exp(-(d*d)/(2.0*(w*glow)*(w*glow)))
            if a < 0.002: 
                continue
            out[i]=_add(out[i], (int(pr*br*a), int(pg*br*a), int(pb*br*a)))
    # scanline highlight
    hl = u
    for i in range(n):
        x = i / max(1.0,(n-1))
        d = abs(x - hl)
        a = math.exp(-(d*d)/(2.0*(0.03+softness*0.08)**2)) * 0.25
        if a > 0.002:
            out[i]=_add(out[i], (int(255*br*a), int(120*br*a), int(255*br*a)))
    return out

def _arduino_emit(*, layout: dict, params: dict) -> str:
    n=int(layout["num_leds"])
    pin=int(layout["led_pin"])
    br=float(params.get("brightness",1.0))
    speed=max(0.1,float(params.get("speed",1.0)))
    density=float(params.get("density",0.55))
    width=float(params.get("width",0.35))
    softness=float(params.get("softness",0.45))

    br = 0.0 if br<0.0 else (1.0 if br>1.0 else br)
    density = 0.0 if density<0.0 else (1.0 if density>1.0 else density)
    softness = 0.0 if softness<0.0 else (1.0 if softness>1.0 else softness)
    if width < 0.05: width = 0.05
    if width > 1.0: width = 1.0

    blocks = 6 + int(round((1.0/width)*2.5))
    if blocks < 6: blocks = 6
    if blocks > 30: blocks = 30
    glow = 0.6 + softness*2.2
    scan = 0.5 + speed*0.6
    bucket_ms = int(max(120.0, min(60000.0, 1000.0 / max(0.05, scan))))

    return f"""// Generated by Modulo (Effect: neon_city)
#include <FastLED.h>
#include <math.h>

#define NUM_LEDS {n}
#define LED_PIN {pin}
CRGB leds[NUM_LEDS];

static inline float clamp01(float x) {{
  if (x < 0.0f) return 0.0f;
  if (x > 1.0f) return 1.0f;
  return x;
}}

static inline uint32_t hash_u32(uint32_t x) {{
  x ^= 0x9E3779B9u;
  x *= 0x85EBCA6Bu;
  x ^= (x >> 13);
  x *= 0xC2B2AE35u;
  x ^= (x >> 16);
  return x;
}}

static inline float u01(uint32_t h) {{
  return (float)(h & 0xFFFFFFu) / 16777216.0f;
}}

static inline void hsv_to_rgb(float h, float s, float v, uint8_t* r, uint8_t* g, uint8_t* b) {{
  float hh = fmodf(h, 1.0f) * 6.0f;
  int i = (int)floorf(hh) % 6;
  float f = hh - (float)i;
  float p = v * (1.0f - s);
  float q = v * (1.0f - f * s);
  float t = v * (1.0f - (1.0f - f) * s);
  float rr,gg,bb;
  if (i==0) {{ rr=v; gg=t; bb=p; }}
  else if (i==1) {{ rr=q; gg=v; bb=p; }}
  else if (i==2) {{ rr=p; gg=v; bb=t; }}
  else if (i==3) {{ rr=p; gg=q; bb=v; }}
  else if (i==4) {{ rr=t; gg=p; bb=v; }}
  else {{ rr=v; gg=p; bb=q; }}
  *r = (uint8_t)(rr*255.0f);
  *g = (uint8_t)(gg*255.0f);
  *b = (uint8_t)(bb*255.0f);
}}

static inline float gauss(float d, float sigma) {{
  return expf(-(d*d) / (2.0f*sigma*sigma));
}}

static inline void add_rgb(uint8_t* r, uint8_t* g, uint8_t* b, float ar, float ag, float ab) {{
  float rr = fminf(255.0f, (float)(*r) + ar);
  float gg = fminf(255.0f, (float)(*g) + ag);
  float bb = fminf(255.0f, (float)(*b) + ab);
  *r = (uint8_t)rr; *g = (uint8_t)gg; *b = (uint8_t)bb;
}}

void setup() {{
  FastLED.addLeds<WS2812B, LED_PIN, GRB>(leds, NUM_LEDS);
  FastLED.setBrightness(255);
}}

void loop() {{
  unsigned long now = millis();
  unsigned long bucket = now / (unsigned long){bucket_ms};
  float u = (float)(now % (unsigned long){bucket_ms}) / (float){bucket_ms};

  float br = clamp01((float){br}f);
  float density = clamp01((float){density}f);
  float glow = (float){glow}f;

  // background
  for (int i=0; i<NUM_LEDS; i++) {{
    float x = (NUM_LEDS<=1)?0.0f:((float)i/(float)(NUM_LEDS-1));
    float hue = fmodf(0.78f + 0.1f*sinf(u*(float){speed}f*0.05f) + x*0.15f, 1.0f);
    float vv = 0.06f + 0.10f*sinf(2.0f*3.1415926f*(x + u*(float){speed}f*0.02f))*0.5f;
    uint8_t r,g,b;
    hsv_to_rgb(hue, 1.0f, br*vv, &r,&g,&b);
    leds[i] = CRGB(r,g,b);
  }}

  const int blocks = {blocks};
  for (int b=0; b<blocks; b++) {{
    uint32_t h = hash_u32((uint32_t)bucket ^ (uint32_t)(b*131));
    if (u01(h) > (0.25f + 0.65f*density)) continue;

    float x0 = u01(h);
    float w = 0.03f + (float){width}f*(0.05f + 0.12f*u01(hash_u32(h ^ 0x0000BEEFu)));
    float hue = fmodf(0.85f + 0.25f*u01(hash_u32(h ^ 0x00001234u)) + u*(float){speed}f*0.03f, 1.0f);
    uint8_t pr,pg,pb;
    hsv_to_rgb(hue, 1.0f, 1.0f, &pr,&pg,&pb);
    float amp = (0.35f + 0.65f*u01(hash_u32(h ^ 0x00004444u))) * (0.5f + 0.5f*sinf(2.0f*3.1415926f*(u + (float)b*0.17f)));

    for (int i=0; i<NUM_LEDS; i++) {{
      float x = (NUM_LEDS<=1)?0.0f:((float)i/(float)(NUM_LEDS-1));
      float d = fabsf(x - x0);
      d = fminf(d, 1.0f - d);
      float a = fmaxf(0.0f, 1.0f - d/fmaxf(1e-6f,w));
      a = a*a * amp;
      a *= gauss(d, w*glow);
      if (a < 0.002f) continue;
      float kf = br*a;
      add_rgb(&leds[i].r, &leds[i].g, &leds[i].b, (float)pr*kf, (float)pg*kf, (float)pb*kf);
    }}
  }}

  // scanline highlight
  float hl = u;
  float sig = 0.03f + (float){softness}f*0.08f;
  for (int i=0; i<NUM_LEDS; i++) {{
    float x = (NUM_LEDS<=1)?0.0f:((float)i/(float)(NUM_LEDS-1));
    float d = fabsf(x - hl);
    float a = gauss(d, sig) * 0.25f;
    if (a < 0.002f) continue;
    float kf = br*a;
    add_rgb(&leds[i].r, &leds[i].g, &leds[i].b, 255.0f*kf, 120.0f*kf, 255.0f*kf);
  }}

  FastLED.show();
  delay(1);
}}
"""

def register_neon_city():
    return register(BehaviorDef(
        "neon_city",
        title="Neon City",
        uses=USES,
        preview_emit=_preview_emit,
        arduino_emit=_arduino_emit,
    ))
