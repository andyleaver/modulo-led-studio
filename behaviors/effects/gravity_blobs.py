from __future__ import annotations
SHIPPED = True

from typing import List, Tuple
import math

from behaviors.registry import BehaviorDef, register

RGB = Tuple[int,int,int]

def _clamp01(x: float) -> float:
    if x < 0.0: return 0.0
    if x > 1.0: return 1.0
    return x

def _hsv_to_rgb(h: float, s: float, v: float) -> RGB:
    h = (h % 1.0) * 6.0
    i = int(h) % 6
    f = h - float(i)
    p = v * (1.0 - s)
    q = v * (1.0 - f * s)
    t = v * (1.0 - (1.0 - f) * s)
    if i == 0: r,g,b = v,t,p
    elif i == 1: r,g,b = q,v,p
    elif i == 2: r,g,b = p,v,t
    elif i == 3: r,g,b = p,q,v
    elif i == 4: r,g,b = t,p,v
    else: r,g,b = v,p,q
    return (int(r*255)&255, int(g*255)&255, int(b*255)&255)

USES = ["brightness","speed","density","softness","width"]

def _preview_emit(*, num_leds: int, params: dict, t: float) -> List[RGB]:
    n = max(1, int(num_leds))
    br = _clamp01(float(params.get("brightness", 1.0)))
    speed = max(0.1, float(params.get("speed", 1.0)))
    density = _clamp01(float(params.get("density", 0.55)))  # blob count (fixed 3..6)
    softness = _clamp01(float(params.get("softness", 0.5))) # threshold softness
    width = _clamp01(float(params.get("width", 0.35)))      # blob radius
    if width < 0.06: width = 0.06

    blobs = 3 + int(round(density*3.0))  # 3..6
    rad = 0.08 + width*0.22
    th = 0.85 - softness*0.35

    out=[]
    for i in range(n):
        x = i / max(1.0, (n-1))
        field = 0.0
        hue = 0.0
        for b in range(blobs):
            # blob centers move with different frequencies
            cx = 0.5 + 0.42*math.sin(2.0*math.pi*(t*speed*0.08 + b*0.17))
            d = abs(x - cx)
            d = min(d, 1.0-d)  # wrap
            f = (rad*rad) / (d*d + rad*rad)
            field += f
            hue += f * (0.15*b + t*0.04)
        # normalize
        field = field / float(blobs)
        hue = (hue / max(1e-6, field*blobs)) % 1.0
        # threshold to get "metaball" look
        v = _clamp01((field - th) / max(0.05, (1.0-th)))
        # soften edges
        v = pow(v, 0.65 + softness*1.2)
        r,g,b = _hsv_to_rgb(hue, 1.0, br*(0.08 + 0.92*v))
        out.append((r,g,b))
    return out

def _arduino_emit(*, layout: dict, params: dict) -> str:
    n = int(layout["num_leds"])
    pin = int(layout["led_pin"])
    br = float(params.get("brightness", 1.0))
    speed = max(0.1, float(params.get("speed", 1.0)))
    density = float(params.get("density", 0.55))
    softness = float(params.get("softness", 0.5))
    width = float(params.get("width", 0.35))

    if br < 0.0: br = 0.0
    if br > 1.0: br = 1.0
    if density < 0.0: density = 0.0
    if density > 1.0: density = 1.0
    if softness < 0.0: softness = 0.0
    if softness > 1.0: softness = 1.0
    if width < 0.06: width = 0.06
    if width > 1.0: width = 1.0

    blobs = 3 + int(round(density*3.0))
    rad = 0.08 + width*0.22
    th = 0.85 - softness*0.35
    period_ms = int(max(450.0, min(60000.0, 20000.0 / speed)))

    return f"""// Generated by Modulo (Effect: gravity_blobs)
#include <FastLED.h>
#include <math.h>

#define NUM_LEDS {n}
#define LED_PIN {pin}
CRGB leds[NUM_LEDS];

static inline float clamp01(float x) {{
  if (x < 0.0f) return 0.0f;
  if (x > 1.0f) return 1.0f;
  return x;
}}

static inline void hsv_to_rgb(float h, float s, float v, uint8_t* r, uint8_t* g, uint8_t* b) {{
  float hh = fmodf(h, 1.0f) * 6.0f;
  int i = (int)floorf(hh) % 6;
  float f = hh - (float)i;
  float p = v * (1.0f - s);
  float q = v * (1.0f - f * s);
  float t = v * (1.0f - (1.0f - f) * s);
  float rr,gg,bb;
  if (i==0) {{ rr=v; gg=t; bb=p; }}
  else if (i==1) {{ rr=q; gg=v; bb=p; }}
  else if (i==2) {{ rr=p; gg=v; bb=t; }}
  else if (i==3) {{ rr=p; gg=q; bb=v; }}
  else if (i==4) {{ rr=t; gg=p; bb=v; }}
  else {{ rr=v; gg=p; bb=q; }}
  *r = (uint8_t)(rr*255.0f);
  *g = (uint8_t)(gg*255.0f);
  *b = (uint8_t)(bb*255.0f);
}}

void setup() {{
  FastLED.addLeds<WS2812B, LED_PIN, GRB>(leds, NUM_LEDS);
  FastLED.setBrightness(255);
}}

void loop() {{
  unsigned long now = millis();
  float phase = (float)(now % (unsigned long){period_ms}) / (float){period_ms};
  float t = phase;
  float br = clamp01((float){br}f);

  int blobs = {blobs};
  float rad = (float){rad}f;
  float th = (float){th}f;
  float softness = clamp01((float){softness}f);

  for (int i=0; i<NUM_LEDS; i++) {{
    float x = (NUM_LEDS <= 1) ? 0.0f : ((float)i / (float)(NUM_LEDS - 1));
    float field = 0.0f;
    float hue_acc = 0.0f;

    for (int b=0; b<blobs; b++) {{
      float cx = 0.5f + 0.42f*sinf(2.0f*3.1415926f*(t*(float){speed}f*0.08f + (float)b*0.17f));
      float d = fabsf(x - cx);
      d = fminf(d, 1.0f - d);
      float f = (rad*rad) / (d*d + rad*rad);
      field += f;
      hue_acc += f * (0.15f*(float)b + t*0.04f);
    }}

    field = field / (float)blobs;
    float hue = fmodf(hue_acc / fmaxf(1e-6f, field*(float)blobs), 1.0f);

    float v = clamp01((field - th) / fmaxf(0.05f, (1.0f - th)));
    v = powf(v, 0.65f + softness*1.2f);

    uint8_t r,g,b;
    hsv_to_rgb(hue, 1.0f, br*(0.08f + 0.92f*v), &r,&g,&b);
    leds[i] = CRGB(r,g,b);
  }}

  FastLED.show();
  delay(1);
}}
"""

def register_gravity_blobs():
    return register(BehaviorDef(
        "gravity_blobs",
        title="Gravity Blobs (Metaballs)",
        uses=USES,
        preview_emit=_preview_emit,
        arduino_emit=_arduino_emit,
    ))
