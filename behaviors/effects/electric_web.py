from __future__ import annotations
SHIPPED = True

from typing import List, Tuple
import math

from behaviors.registry import BehaviorDef, register

RGB = Tuple[int,int,int]

def _clamp01(x: float) -> float:
    if x < 0.0: return 0.0
    if x > 1.0: return 1.0
    return x

def _hash_u32(x: int) -> int:
    x = (x ^ 0x9E3779B9) & 0xFFFFFFFF
    x = (x * 0x85EBCA6B) & 0xFFFFFFFF
    x = (x ^ (x >> 13)) & 0xFFFFFFFF
    x = (x * 0xC2B2AE35) & 0xFFFFFFFF
    x = (x ^ (x >> 16)) & 0xFFFFFFFF
    return x

def _u01(h: int) -> float:
    return float(h & 0xFFFFFF) / float(0x1000000)

def _add(a: RGB, b: RGB) -> RGB:
    return (min(255, a[0]+b[0]), min(255, a[1]+b[1]), min(255, a[2]+b[2]))

USES = ["color","brightness","speed","density","softness","width"]

def _preview_emit(*, num_leds: int, params: dict, t: float) -> List[RGB]:
    n = max(1, int(num_leds))
    col = params.get("color",(130,220,255))
    base = (int(col[0])&255, int(col[1])&255, int(col[2])&255)
    br = _clamp01(float(params.get("brightness", 1.0)))
    speed = max(0.1, float(params.get("speed", 1.0)))
    density = _clamp01(float(params.get("density", 0.55)))   # branches
    softness = _clamp01(float(params.get("softness", 0.45))) # decay
    width = _clamp01(float(params.get("width", 0.18)))       # thickness
    if width < 0.03: width = 0.03

    branches = 2 + int(round(density * 6.0))  # 2..8
    decay = 0.10 + softness * 0.45
    thick = 0.8 + width * 4.0

    # bucketed web changes
    bps = speed * 0.5
    bucket = int(t * bps)
    u = (t * bps) - bucket

    out = [(0,0,0) for _ in range(n)]
    for b in range(branches):
        h = _hash_u32(bucket ^ (b*911))
        a = _u01(h)
        c = _u01(_hash_u32(h ^ 0x1234))
        if a > c: a,c = c,a
        # add a "kink" point to look branched
        k = _u01(_hash_u32(h ^ 0xBEEF))
        m = a + (c-a) * k
        # animate slight jitter
        j = (u - 0.5) * (0.02 + 0.05*density)
        a2 = max(0.0, min(1.0, a + j))
        m2 = max(0.0, min(1.0, m - j))
        c2 = max(0.0, min(1.0, c + j*0.5))

        def draw_seg(p0: float, p1: float, gain: float):
            if p1 < p0: p0,p1 = p1,p0
            i0 = int(p0 * (n-1 if n>1 else 1))
            i1 = int(p1 * (n-1 if n>1 else 1))
            for i in range(i0, i1+1):
                x = i / max(1.0, (n-1))
                # distance to segment in 1D is just within bounds -> 0 else edge dist
                d = 0.0
                if x < p0: d = p0 - x
                elif x > p1: d = x - p1
                # thickness falloff
                a = math.exp(-(d*d)/(2.0*(0.015*thick)*(0.015*thick))) * gain
                if a < 0.002: 
                    continue
                # add flicker along segment
                flick = 0.6 + 0.4*math.sin(2.0*math.pi*(x*8.0 + u*2.0 + b))
                a *= flick
                add = (int(base[0]*br*a), int(base[1]*br*a), int(base[2]*br*a))
                out[i] = _add(out[i], (min(255,add[0]),min(255,add[1]),min(255,add[2])))

        # main trunk and branch
        draw_seg(a2, m2, 1.0)
        draw_seg(m2, c2, 0.85)
        # glow nodes
        for node, gain in ((a2,1.0),(m2,1.15),(c2,0.95)):
            idx = node * (n-1 if n>1 else 1)
            for i in range(n):
                d = abs(i - idx)
                if d > 10*decay/thick: 
                    continue
                a = math.exp(-(d*d)/(2.0*(decay*decay))) * gain
                if a < 0.002: 
                    continue
                add = (int(base[0]*br*a), int(base[1]*br*a), int(base[2]*br*a))
                out[i] = _add(out[i], (min(255,add[0]),min(255,add[1]),min(255,add[2])))
    return out

def _arduino_emit(*, layout: dict, params: dict) -> str:
    n = int(layout["num_leds"])
    pin = int(layout["led_pin"])
    col = params.get("color",(130,220,255))
    r0,g0,b0 = int(col[0])&255, int(col[1])&255, int(col[2])&255
    br = float(params.get("brightness", 1.0))
    speed = max(0.1, float(params.get("speed", 1.0)))
    density = float(params.get("density", 0.55))
    softness = float(params.get("softness", 0.45))
    width = float(params.get("width", 0.18))

    if br < 0.0: br = 0.0
    if br > 1.0: br = 1.0
    if density < 0.0: density = 0.0
    if density > 1.0: density = 1.0
    if softness < 0.0: softness = 0.0
    if softness > 1.0: softness = 1.0
    if width < 0.03: width = 0.03
    if width > 1.0: width = 1.0

    branches = 2 + int(round(density * 6.0))
    decay = 0.10 + softness * 0.45
    thick = 0.8 + width * 4.0
    bucket_ms = int(max(250.0, min(60000.0, 2000.0 / (speed*0.5))))

    return f"""// Generated by Modulo (Effect: electric_web)
#include <FastLED.h>
#include <math.h>

#define NUM_LEDS {n}
#define LED_PIN {pin}
CRGB leds[NUM_LEDS];

static inline float clamp01(float x) {{
  if (x < 0.0f) return 0.0f;
  if (x > 1.0f) return 1.0f;
  return x;
}}

static inline uint32_t hash_u32(uint32_t x) {{
  x ^= 0x9E3779B9u;
  x *= 0x85EBCA6Bu;
  x ^= (x >> 13);
  x *= 0xC2B2AE35u;
  x ^= (x >> 16);
  return x;
}}

static inline float u01(uint32_t h) {{
  return (float)(h & 0xFFFFFFu) / 16777216.0f;
}}

static inline float gauss(float d, float sigma) {{
  return expf(-(d*d) / (2.0f*sigma*sigma));
}}

static inline void add_rgb(uint8_t* r, uint8_t* g, uint8_t* b, float ar, float ag, float ab) {{
  float rr = fminf(255.0f, (float)(*r) + ar);
  float gg = fminf(255.0f, (float)(*g) + ag);
  float bb = fminf(255.0f, (float)(*b) + ab);
  *r = (uint8_t)rr; *g = (uint8_t)gg; *b = (uint8_t)bb;
}}

void setup() {{
  FastLED.addLeds<WS2812B, LED_PIN, GRB>(leds, NUM_LEDS);
  FastLED.setBrightness(255);
}}

static inline void draw_node(float node, float gain, float br, float decay, float thick) {{
  float idx = node * (float)(NUM_LEDS - 1);
  for (int i=0; i<NUM_LEDS; i++) {{
    float d = fabsf((float)i - idx);
    float maxd = 10.0f*decay/fmaxf(0.2f, thick);
    if (d > maxd) continue;
    float a = gauss(d, decay) * gain;
    if (a < 0.002f) continue;
    float k = br * a;
    add_rgb(&leds[i].r, &leds[i].g, &leds[i].b, (float){r0}f*k, (float){g0}f*k, (float){b0}f*k);
  }}
}}

static inline void draw_seg(float p0, float p1, float gain, float br, float u, int b, float thick) {{
  if (p1 < p0) {{ float tmp=p0; p0=p1; p1=tmp; }}
  int i0 = (int)(p0 * (float)(NUM_LEDS - 1));
  int i1 = (int)(p1 * (float)(NUM_LEDS - 1));
  if (i0 < 0) i0 = 0;
  if (i1 >= NUM_LEDS) i1 = NUM_LEDS - 1;
  for (int i=i0; i<=i1; i++) {{
    float x = (NUM_LEDS <= 1) ? 0.0f : ((float)i / (float)(NUM_LEDS - 1));
    float d = 0.0f;
    if (x < p0) d = p0 - x;
    else if (x > p1) d = x - p1;
    float a = gauss(d, 0.015f*thick) * gain;
    if (a < 0.002f) continue;
    float flick = 0.6f + 0.4f*sinf(2.0f*3.1415926f*(x*8.0f + u*2.0f + (float)b));
    a *= flick;
    float k = br * a;
    add_rgb(&leds[i].r, &leds[i].g, &leds[i].b, (float){r0}f*k, (float){g0}f*k, (float){b0}f*k);
  }}
}}

void loop() {{
  unsigned long now = millis();
  unsigned long bucket = now / (unsigned long){bucket_ms};
  float u = (float)(now % (unsigned long){bucket_ms}) / (float){bucket_ms};

  float br = clamp01((float){br}f);
  float density = clamp01((float){density}f);
  float thick = (float){thick}f;
  float decay = (float){decay}f;

  for (int i=0; i<NUM_LEDS; i++) leds[i] = CRGB(0,0,0);

  for (int b=0; b<{branches}; b++) {{
    uint32_t h = hash_u32((uint32_t)bucket ^ (uint32_t)(b*911));
    float a = u01(h);
    float c = u01(hash_u32(h ^ 0x00001234u));
    if (a > c) {{ float tmp=a; a=c; c=tmp; }}
    float k = u01(hash_u32(h ^ 0x0000BEEFu));
    float m = a + (c-a)*k;

    float j = (u - 0.5f) * (0.02f + 0.05f*density);
    float a2 = clamp01(a + j);
    float m2 = clamp01(m - j);
    float c2 = clamp01(c + j*0.5f);

    draw_seg(a2, m2, 1.0f, br, u, b, thick);
    draw_seg(m2, c2, 0.85f, br, u, b, thick);

    draw_node(a2, 1.0f, br, decay, thick);
    draw_node(m2, 1.15f, br, decay, thick);
    draw_node(c2, 0.95f, br, decay, thick);
  }}

  FastLED.show();
  delay(1);
}}
"""

def register_electric_web():
    return register(BehaviorDef(
        "electric_web",
        title="Electric Arc Web",
        uses=USES,
        preview_emit=_preview_emit,
        arduino_emit=_arduino_emit,
    ))
