from __future__ import annotations
SHIPPED = True

from typing import List, Tuple
import math
from behaviors.registry import BehaviorDef, register

RGB=Tuple[int,int,int]
USES=["brightness","speed","softness","density","width"]

def _clamp01(x: float) -> float:
    if x<0.0: return 0.0
    if x>1.0: return 1.0
    return x

def _hsv_to_rgb(h: float, s: float, v: float) -> RGB:
    h=(h%1.0)*6.0
    i=int(h)%6
    f=h-float(i)
    p=v*(1.0-s)
    q=v*(1.0-f*s)
    t=v*(1.0-(1.0-f)*s)
    if i==0: r,g,b=v,t,p
    elif i==1: r,g,b=q,v,p
    elif i==2: r,g,b=p,v,t
    elif i==3: r,g,b=p,q,v
    elif i==4: r,g,b=t,p,v
    else: r,g,b=v,p,q
    return (int(r*255)&255,int(g*255)&255,int(b*255)&255)

def _add(a: RGB,b: RGB)->RGB:
    return (min(255,a[0]+b[0]), min(255,a[1]+b[1]), min(255,a[2]+b[2]))

def _preview_emit(*, num_leds:int, params:dict, t:float, state=None)->List[RGB]:
    n=max(1,int(num_leds))
    br=_clamp01(float(params.get("brightness",1.0)))
    speed=max(0.1,float(params.get("speed",1.0)))
    softness=_clamp01(float(params.get("softness",0.45)))
    density=_clamp01(float(params.get("density",0.55))) # sensitivity
    width=_clamp01(float(params.get("width",0.35)))     # burst size
    if width<0.05: width=0.05

    ev=(params.get("_audio_events") or {})
    # kick uses low-band transients (L0/L1/R0/R1)
    kick = max(float(ev.get("l0_tr",0.0) or 0.0), float(ev.get("l1_tr",0.0) or 0.0),
               float(ev.get("r0_tr",0.0) or 0.0), float(ev.get("r1_tr",0.0) or 0.0))

    if state is None or not isinstance(state, dict):
        state={"bursts":[]}
    bursts=state["bursts"]

    if kick>0.5 and (density>0.1):
        bursts.append([0.5, 0.0, 1.0])  # center, radius, life

    dt=1.0/60.0
    grow=(0.10+1.6*speed)
    decay=(0.35+1.25*(1.0-softness))
    sig=(0.010 + width*0.085)*(0.7+1.6*softness)

    out=[(0,0,0) for _ in range(n)]
    new=[]
    for x0,r,life in bursts:
        r = r + grow*dt
        life = life - decay*dt
        if life<=0.0: 
            continue
        new.append([x0,r,life])
        hue = 0.02 + 0.10*math.sin(t*0.9)
        c=_hsv_to_rgb(hue,1.0,1.0)
        for i in range(n):
            x=i/max(1.0,(n-1))
            d=abs(abs(x-x0)-r)
            a=math.exp(-(d*d)/(2.0*sig*sig)) * life
            if a<0.002: 
                continue
            out[i]=_add(out[i], (int(c[0]*br*a), int(c[1]*br*a), int(c[2]*br*a)))
    state["bursts"]=new[-30:]
    return out

def _arduino_emit(*, layout:dict, params:dict)->str:
    n=int(layout["num_leds"]); pin=int(layout["led_pin"])
    br=float(params.get("brightness",1.0))
    speed=max(0.1,float(params.get("speed",1.0)))
    softness=float(params.get("softness",0.45))
    density=float(params.get("density",0.55))
    width=float(params.get("width",0.35))
    if br<0: br=0.0
    if br>1: br=1.0
    if softness<0: softness=0.0
    if softness>1: softness=1.0
    if density<0: density=0.0
    if density>1: density=1.0
    if width<0.05: width=0.05
    if width>1: width=1.0

    alpha=0.10 + 0.35*softness
    grow=(0.10+1.6*speed)
    decay=(0.35+1.25*(1.0-softness))
    sig=(0.010 + width*0.085)*(0.7+1.6*softness)

    MAXB=24

    return f"""// Generated by Modulo (Kick Burst)
#include <FastLED.h>
#include <math.h>

#define NUM_LEDS {n}
#define LED_PIN {pin}
CRGB leds[NUM_LEDS];

// MSGEQ7 pins (default)
const int RESET_PIN = 5;
const int STROBE_PIN = 4;
const int LEFT_PIN = A0;
const int RIGHT_PIN = A1;

// event state
float B[14]={{0}};
float Pk[14]={{0}};
int cd[14]={{0}};

struct Burst {{ float r; float life; bool alive; }};
Burst bursts[{MAXB}];

static inline float clamp01(float x) {{
  if (x<0.0f) return 0.0f;
  if (x>1.0f) return 1.0f;
  return x;
}}
static inline float read01(int pin) {{
  int v=analogRead(pin);
  return clamp01((float)v/1023.0f);
}}
static inline void add_rgb(uint8_t* r, uint8_t* g, uint8_t* b, float ar, float ag, float ab) {{
  float rr=fminf(255.0f,(float)(*r)+ar);
  float gg=fminf(255.0f,(float)(*g)+ag);
  float bb=fminf(255.0f,(float)(*b)+ab);
  *r=(uint8_t)rr; *g=(uint8_t)gg; *b=(uint8_t)bb;
}}
static inline void hsv_to_rgb(float h, float s, float v, uint8_t* r, uint8_t* g, uint8_t* b) {{
  float hh=fmodf(h,1.0f)*6.0f;
  int i=(int)floorf(hh)%6;
  float f=hh-(float)i;
  float p=v*(1.0f-s);
  float q=v*(1.0f-f*s);
  float t=v*(1.0f-(1.0f-f)*s);
  float rr,gg,bb;
  if (i==0) {{ rr=v; gg=t; bb=p; }}
  else if (i==1) {{ rr=q; gg=v; bb=p; }}
  else if (i==2) {{ rr=p; gg=v; bb=t; }}
  else if (i==3) {{ rr=p; gg=q; bb=v; }}
  else if (i==4) {{ rr=t; gg=p; bb=v; }}
  else {{ rr=v; gg=p; bb=q; }}
  *r=(uint8_t)(rr*255.0f); *g=(uint8_t)(gg*255.0f); *b=(uint8_t)(bb*255.0f);
}}

int allocBurst() {{
  for (int i=0;i<{MAXB};i++) if (!bursts[i].alive) return i;
  return -1;
}}

void setup() {{
  FastLED.addLeds<WS2812B, LED_PIN, GRB>(leds, NUM_LEDS);
  FastLED.setBrightness(255);
  pinMode(RESET_PIN, OUTPUT);
  pinMode(STROBE_PIN, OUTPUT);
  digitalWrite(RESET_PIN, LOW);
  digitalWrite(STROBE_PIN, HIGH);
  for (int i=0;i<{MAXB};i++) bursts[i].alive=false;
}}

void loop() {{
  // read 14 bands and compute transients (simple)
  float raw[14];
  digitalWrite(RESET_PIN, HIGH); delayMicroseconds(5); digitalWrite(RESET_PIN, LOW);
  for (int i=0;i<7;i++) {{
    digitalWrite(STROBE_PIN, LOW); delayMicroseconds(30);
    raw[i]=read01(LEFT_PIN);
    raw[i+7]=read01(RIGHT_PIN);
    digitalWrite(STROBE_PIN, HIGH);
  }}

  for (int i=0;i<14;i++) {{
    float prev=B[i];
    B[i]=(1.0f-{alpha}f)*B[i] + {alpha}f*raw[i];
    float d=B[i]-prev;
    Pk[i]=fmaxf(Pk[i]-0.020f, B[i]);
    if (cd[i]>0) {{ cd[i]--; continue; }}
    float thr = 0.05f + Pk[i]*0.25f;
    if (d > thr) cd[i]=4;
  }}

  // kick trigger on low bands transient cooldown set recently
  bool kick = (cd[0]==4)||(cd[1]==4)||(cd[7]==4)||(cd[8]==4);
  if (kick && {density}f>0.10f) {{
    int idx=allocBurst();
    if (idx>=0) {{ bursts[idx].r=0.0f; bursts[idx].life=1.0f; bursts[idx].alive=true; }}
  }}

  // render
  for (int i=0;i<NUM_LEDS;i++) leds[i]=CRGB(0,0,0);

  const float dt=1.0f/60.0f;
  float br=clamp01((float){br}f);
  float grow=(float){grow}f;
  float decay=(float){decay}f;
  float sig=(float){sig}f;

  float tt=millis()/1000.0f;
  float hue=0.02f + 0.10f*sinf(tt*0.9f);
  uint8_t pr,pg,pb; hsv_to_rgb(hue,1.0f,1.0f,&pr,&pg,&pb);

  for (int bi=0; bi<{MAXB}; bi++) {{
    if (!bursts[bi].alive) continue;
    bursts[bi].r += grow*dt;
    bursts[bi].life -= decay*dt;
    if (bursts[bi].life<=0.0f) {{ bursts[bi].alive=false; continue; }}

    for (int i=0;i<NUM_LEDS;i++) {{
      float x=(NUM_LEDS<=1)?0.0f:((float)i/(float)(NUM_LEDS-1));
      float d=fabsf(fabsf(x-0.5f)-bursts[bi].r);
      float a=expf(-(d*d)/(2.0f*sig*sig)) * bursts[bi].life;
      if (a<0.002f) continue;
      float kf=br*a;
      add_rgb(&leds[i].r,&leds[i].g,&leds[i].b, (float)pr*kf,(float)pg*kf,(float)pb*kf);
    }}
  }}

  FastLED.show();
  delay(1);
}}
"""

def register_kick_burst():
    return register(BehaviorDef(
        "kick_burst",
        title="Kick Burst (Audio Events)",
        uses=USES,
        preview_emit=_preview_emit,
        arduino_emit=_arduino_emit,
    ))
